<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Invaders</title>
    <style>
        body {
            margin: 0;
            padding: 10px;
            background: 
                radial-gradient(circle at 25% 25%, #654321 2px, transparent 3px),
                radial-gradient(circle at 75% 75%, #5D4037 1px, transparent 2px),
                radial-gradient(circle at 50% 10%, #8B4513 1px, transparent 2px),
                radial-gradient(circle at 10% 90%, #654321 1px, transparent 2px),
                linear-gradient(to bottom, #8B4513 0%, #654321 25%, #8B4513 50%, #5D4037 75%, #8B4513 100%);
            background-size: 
                20px 20px,
                15px 15px,
                12px 12px,
                18px 18px,
                100% 100%;
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            box-sizing: border-box;
        }

        .main-container {
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
            max-width: 100vw;
            max-height: 100vh;
            box-sizing: border-box;
        }

        .game-container {
            background: #000;
            border: 4px solid #444;
            position: relative;
            width: min(1250px, 70vw);
            height: min(875px, 80vh);
            overflow: hidden;
            flex-shrink: 0;
        }

        .control-panel {
            background: rgba(0, 0, 0, 0.8);
            border: 4px solid #444;
            border-radius: 10px;
            padding: 15px;
            width: min(220px, 25vw);
            max-height: min(875px, 80vh);
            color: #fff;
            font-size: 13px;
            overflow-y: auto;
            flex-shrink: 0;
            box-sizing: border-box;
        }

        .control-section {
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            border: 2px solid #666;
        }

        .control-section h3 {
            margin: 0 0 10px 0;
            color: #ffff00;
            font-size: 16px;
            text-align: center;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            padding: 5px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        .control-title {
            color: #00ff00;
            font-size: 18px;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .game-canvas {
            width: 100%;
            height: 100%;
            position: relative;
            background: 
                radial-gradient(circle at 20% 30%, #2C1810 1px, transparent 2px),
                radial-gradient(circle at 80% 70%, #1A0F08 1px, transparent 1.5px),
                radial-gradient(circle at 60% 20%, #3D2914 1px, transparent 2px),
                linear-gradient(to bottom, #3D2914 0%, #2C1810 25%, #3D2914 50%, #2C1810 75%, #3D2914 100%);
            background-size: 
                16px 16px,
                12px 12px,
                14px 14px,
                100% 100%;
        }

        .score {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-size: 20px;
            z-index: 100;
        }

        .lives {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #fff;
            font-size: 20px;
            z-index: 100;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 36px;
            text-align: center;
            z-index: 200;
            display: none;
        }

        .instructions {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 14px;
            text-align: center;
            z-index: 100;
        }

        .sprite {
            position: absolute;
            image-rendering: pixelated;
        }

        .player {
            width: 100px;
            height: 80px;
        }

        .enemy {
            width: 60px;
            height: 60px;
        }

        .projectile {
            width: 16px;
            height: 24px;
        }

        .enemy-projectile {
            width: 20px;
            height: 20px;
        }

        .fire-spread {
            width: 24px;
            height: 24px;
        }

        .vertical-blast {
            width: 40px;
            position: absolute;
            pointer-events: none;
            z-index: 150;
        }

        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .slider-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .slider {
            width: 120px;
            height: 25px;
            background: #333;
            border: 2px solid #666;
            border-radius: 5px;
            outline: none;
            opacity: 0.8;
            cursor: pointer;
        }

        .slider:hover {
            opacity: 1;
        }

        .slider-value {
            background: rgba(0, 0, 0, 0.5);
            padding: 3px 8px;
            border-radius: 3px;
            border: 1px solid #888;
            min-width: 30px;
            text-align: center;
        }

        .level-display {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 24px;
            z-index: 100;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .boss-health {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 18px;
            z-index: 100;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .boss-name {
            margin-bottom: 5px;
            font-size: 20px;
            color: #ff4444;
            font-weight: bold;
        }

        .health-bar {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .health-bar-bg {
            width: 200px;
            height: 12px;
            background: #333;
            border: 2px solid #666;
            border-radius: 6px;
            overflow: hidden;
        }

        .health-bar-fill {
            height: 100%;
            background: linear-gradient(to right, #ff4444, #ff8844, #44ff44);
            transition: width 0.3s ease;
            border-radius: 3px;
        }

        .powerup {
            width: 40px;
            height: 40px;
        }

        .powerup-indicator {
            position: absolute;
            top: 60px;
            left: 10px;
            color: #fff;
            font-size: 14px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            border: 2px solid #444;
        }

        .start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(45deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            color: #fff;
            text-align: center;
        }

        .start-screen.hidden {
            display: none;
        }

        .game-title {
            font-size: 4rem;
            color: #00ff00;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
            margin-bottom: 2rem;
            font-weight: bold;
        }

        .start-subtitle {
            font-size: 1.5rem;
            color: #ffff00;
            margin-bottom: 3rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .start-instruction {
            font-size: 1.8rem;
            color: #fff;
            padding: 15px 30px;
            border: 3px solid #00ff00;
            border-radius: 10px;
            background: rgba(0, 255, 0, 0.1);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .dimension-selection {
            margin: 2rem 0;
            display: flex;
            gap: 3rem;
            justify-content: center;
            align-items: center;
        }

        .dimension-option {
            background: rgba(0, 0, 0, 0.3);
            border: 3px solid #666;
            border-radius: 15px;
            padding: 2rem;
            width: 250px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .dimension-option:hover {
            border-color: #00ff00;
            background: rgba(0, 255, 0, 0.1);
            transform: scale(1.05);
        }

        .dimension-option.selected {
            border-color: #00ff00;
            background: rgba(0, 255, 0, 0.2);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }

        .dimension-title {
            font-size: 1.8rem;
            font-weight: bold;
            margin-bottom: 1rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .overworld .dimension-title {
            color: #00ff00;
        }

        .nether .dimension-title {
            color: #ff4444;
        }

        .dimension-description {
            font-size: 1rem;
            line-height: 1.4;
            margin-bottom: 1.5rem;
            color: #ccc;
        }

        .dimension-enemies {
            font-size: 0.9rem;
            color: #ffaa00;
            font-weight: bold;
        }

        .dimension-bosses {
            font-size: 0.85rem;
            color: #ff6666;
            margin-top: 0.5rem;
        }

        /* Nether dimension background */
        body.nether-dimension {
            background: 
                radial-gradient(circle at 20% 30%, #8B0000 2px, transparent 3px),
                radial-gradient(circle at 80% 20%, #DC143C 1px, transparent 2px),
                radial-gradient(circle at 40% 80%, #B22222 1px, transparent 2px),
                radial-gradient(circle at 60% 60%, #8B0000 1px, transparent 2px),
                linear-gradient(to bottom, #B22222 0%, #8B0000 25%, #DC143C 50%, #8B0000 75%, #B22222 100%);
            background-size: 
                25px 25px,
                18px 18px,
                15px 15px,
                20px 20px,
                100% 100%;
        }
    </style>
</head>
<body>
    <div class="start-screen" id="startScreen">
        <div class="game-title">MINECRAFT INVADERS</div>
        <div class="start-subtitle">Choose Your Dimension</div>
        
        <div class="dimension-selection">
            <div class="dimension-option overworld selected" data-dimension="overworld">
                <div class="dimension-title">OVERWORLD</div>
                <div class="dimension-description">The familiar realm with grassy plains and diverse creatures</div>
                <div class="dimension-enemies">Enemies: Zombies, Creepers, Skeletons</div>
                <div class="dimension-bosses">Bosses: Witch, Evoker, Ravager, Warden</div>
            </div>
            
            <div class="dimension-option nether" data-dimension="nether">
                <div class="dimension-title">NETHER</div>
                <div class="dimension-description">A hellish dimension with crimson landscapes and fiery foes</div>
                <div class="dimension-enemies">Enemies: Piglins, Zombie Piglins, Wither Skeletons</div>
                <div class="dimension-bosses">Bosses: Blaze, Ghast, Wither</div>
            </div>
        </div>
        
        <div class="start-instruction">Press ENTER to Start</div>
    </div>
    
    <audio id="startMusic" loop>
        <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvGIcAzqH0fPTfSkEMHy88+OLTAQYSM" type="audio/wav">
    </audio>
    
    <div class="main-container">
        <div class="game-container">
            <div class="game-canvas" id="gameCanvas">
                <div class="score">Score: <span id="score">0</span></div>
                <div class="lives">Lives: <span id="lives">3</span></div>
                <div class="level-display">Level <span id="level">1</span></div>
                
                <div class="boss-health" id="bossHealth" style="display: none;">
                    <div class="boss-name" id="bossName">Boss</div>
                    <div class="health-bar">
                        <div class="health-bar-bg">
                            <div class="health-bar-fill" id="healthBarFill"></div>
                        </div>
                        <span id="healthText">10/10</span>
                    </div>
                </div>
                
                <div class="powerup-indicator" id="powerupIndicator" style="display: none;">
                    Active: <span id="activePowerup"></span>
                </div>
                
                <div class="game-over" id="gameOver">
                    <div>GAME OVER</div>
                    <div style="font-size: 18px; margin-top: 10px;">Press R to restart</div>
                </div>
                <div class="instructions">
                    Use arrow keys to move • Spacebar to shoot eggs • Defeat all hostile mobs!
                </div>
            </div>
        </div>
        
        <div class="control-panel">
            <div class="control-title">GAME CONTROLS</div>
            
            <div class="control-section">
                <h3>⚔️ Difficulty</h3>
                <div class="slider-container">
                    <div class="slider-row">
                        <label>Snowball Rate:</label>
                        <span id="snowballValue" class="slider-value">1.0x</span>
                    </div>
                    <input type="range" id="snowballSlider" class="slider" min="0.1" max="2" step="0.1" value="1">
                </div>
            </div>
            
            <div class="control-section">
                <h3>📊 Statistics</h3>
                <div class="stat-row">
                    <span>High Score:</span>
                    <span id="highScore">0</span>
                </div>
                <div class="stat-row">
                    <span>Wins:</span>
                    <span id="wins">0</span>
                </div>
                <div class="stat-row">
                    <span>Losses:</span>
                    <span id="losses">0</span>
                </div>
            </div>
            
            <div class="control-section">
                <h3>🎮 Controls</h3>
                <div style="font-size: 12px; line-height: 1.4;">
                    <div>🔄 Arrow Keys: Move</div>
                    <div>🥚 Spacebar: Shoot Eggs</div>
                    <div>🔄 R: Restart Game</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Game statistics
        let gameStats = {
            highScore: parseInt(localStorage.getItem('minecraftInvadersHighScore')) || 0,
            wins: parseInt(localStorage.getItem('minecraftInvadersWins')) || 0,
            losses: parseInt(localStorage.getItem('minecraftInvadersLosses')) || 0
        };

        // Power-up system
        const powerUps = {
            active: {},
            items: [],
            types: {
                goldenApple: { name: 'Golden Apple', duration: 5000, effect: 'invincibility' },
                firePotion: { name: 'Fire Potion', duration: 20000, effect: 'rapidFire' },
                totem: { name: 'Totem of Undying', duration: 0, effect: 'extraLife' },
                redstone: { name: 'Redstone', duration: 15000, effect: 'slowEnemies' },
                tnt: { name: 'TNT', duration: 0, effect: 'explosion' },
                blazeRod: { name: 'Blaze Rod', duration: 25000, effect: 'spreadingFire' },
                stevesLavaChicken: { name: "Steve's Lava Chicken", duration: 5000, effect: 'lavaChicken' },
                shield: { name: 'Shield', duration: 10000, effect: 'shield' },
                iceBlock: { name: 'Ice Block', duration: 10000, effect: 'freezeEnemies' }
            }
        };

        // Game state
        const game = {
            canvas: document.getElementById('gameCanvas'),
            player: null,
            capturedPlayer: null,
            enemies: [],
            projectiles: [],
            enemyProjectiles: [],
            score: 0,
            lives: 3,
            gameRunning: false,
            gameStarted: false,
            keys: {},
            lastShot: 0,
            level: 1,
            snowballFrequency: 1,
            enemiesDefeated: 0,
            totalEnemiesInLevel: 0,
            lastPowerUpSpawn: 0,
            nextExplosiveShot: false,
            fireSpreadEffects: [],
            bossEntranceInProgress: false,
            bossCreated: false,
            levelCompleting: false,
            formationPositions: [],
            enemySpawnQueue: [],
            lastEnemySpawn: 0,
            formationComplete: false,
            selectedDimension: 'overworld'
        };

        // Initialize UI
        function initUI() {
            document.getElementById('highScore').textContent = gameStats.highScore;
            document.getElementById('wins').textContent = gameStats.wins;
            document.getElementById('losses').textContent = gameStats.losses;
            document.getElementById('level').textContent = game.level;
            
            // Snowball slider event
            const slider = document.getElementById('snowballSlider');
            slider.addEventListener('input', (e) => {
                game.snowballFrequency = parseFloat(e.target.value);
                document.getElementById('snowballValue').textContent = game.snowballFrequency.toFixed(1) + 'x';
            });
        }

        // Save statistics
        function saveStats() {
            localStorage.setItem('minecraftInvadersHighScore', gameStats.highScore);
            localStorage.setItem('minecraftInvadersWins', gameStats.wins);
            localStorage.setItem('minecraftInvadersLosses', gameStats.losses);
        }

        // Update high score
        function updateHighScore() {
            if (game.score > gameStats.highScore) {
                gameStats.highScore = game.score;
                document.getElementById('highScore').textContent = gameStats.highScore;
                saveStats();
            }
        }

        function showBossHealth(bossType, currentHealth, maxHealth) {
            const bossHealthEl = document.getElementById('bossHealth');
            const bossNameEl = document.getElementById('bossName');
            const healthBarFill = document.getElementById('healthBarFill');
            const healthText = document.getElementById('healthText');
            
            const bossNames = {
                'witch': 'Witch',
                'evoker': 'Evoker', 
                'ravager': 'Ravager',
                'warden': 'Warden'
            };
            
            bossNameEl.textContent = bossNames[bossType] || 'Boss';
            healthText.textContent = `${currentHealth}/${maxHealth}`;
            
            const healthPercent = (currentHealth / maxHealth) * 100;
            healthBarFill.style.width = healthPercent + '%';
            
            bossHealthEl.style.display = 'block';
        }

        function updateBossHealth(currentHealth, maxHealth) {
            const healthBarFill = document.getElementById('healthBarFill');
            const healthText = document.getElementById('healthText');
            
            healthText.textContent = `${currentHealth}/${maxHealth}`;
            
            const healthPercent = (currentHealth / maxHealth) * 100;
            healthBarFill.style.width = healthPercent + '%';
        }

        function hideBossHealth() {
            document.getElementById('bossHealth').style.display = 'none';
        }

        // Sound effects using Web Audio API
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(frequency, duration, type = 'square') {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = frequency;
            oscillator.type = type;
            
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }
        
        const sounds = {
            shoot: () => playSound(800, 0.1),
            hit: () => {
                // Create a crash sound with multiple frequencies and noise
                const oscillator1 = audioContext.createOscillator();
                const oscillator2 = audioContext.createOscillator();
                const oscillator3 = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator1.connect(gainNode);
                oscillator2.connect(gainNode);
                oscillator3.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Multiple harsh frequencies for crash effect
                oscillator1.frequency.value = 100;
                oscillator2.frequency.value = 80;
                oscillator3.frequency.value = 60;
                
                // Use sawtooth wave for harsher sound
                oscillator1.type = 'sawtooth';
                oscillator2.type = 'square';
                oscillator3.type = 'triangle';
                
                // Sharp attack and quick decay for crash effect
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                
                const startTime = audioContext.currentTime;
                const duration = 0.4;
                
                oscillator1.start(startTime);
                oscillator2.start(startTime);
                oscillator3.start(startTime);
                
                oscillator1.stop(startTime + duration);
                oscillator2.stop(startTime + duration);
                oscillator3.stop(startTime + duration);
            },
            enemyHit: () => playSound(150, 0.3),
            gameOver: () => {
                // Create a long, dramatic explosion sound effect
                const duration = 3.0; // 3 second explosion
                const startTime = audioContext.currentTime;
                
                // Initial explosion blast - sharp attack
                const blastOsc = audioContext.createOscillator();
                const blastGain = audioContext.createGain();
                
                blastOsc.connect(blastGain);
                blastGain.connect(audioContext.destination);
                
                blastOsc.frequency.value = 80;
                blastOsc.type = 'sawtooth';
                
                // Sharp explosion attack
                blastGain.gain.setValueAtTime(0.4, startTime);
                blastGain.gain.exponentialRampToValueAtTime(0.1, startTime + 0.2);
                blastGain.gain.exponentialRampToValueAtTime(0.01, startTime + 1.0);
                
                blastOsc.start(startTime);
                blastOsc.stop(startTime + 1.0);
                
                // Rumbling bass frequencies
                for (let i = 0; i < 3; i++) {
                    const rumbleOsc = audioContext.createOscillator();
                    const rumbleGain = audioContext.createGain();
                    
                    rumbleOsc.connect(rumbleGain);
                    rumbleGain.connect(audioContext.destination);
                    
                    rumbleOsc.frequency.value = 40 + (i * 20); // 40, 60, 80 Hz
                    rumbleOsc.type = 'square';
                    
                    const rumbleStart = startTime + (i * 0.1);
                    rumbleGain.gain.setValueAtTime(0.2 - (i * 0.05), rumbleStart);
                    rumbleGain.gain.exponentialRampToValueAtTime(0.01, rumbleStart + duration);
                    
                    rumbleOsc.start(rumbleStart);
                    rumbleOsc.stop(rumbleStart + duration);
                }
                
                // High-frequency crackling/debris sounds
                for (let i = 0; i < 5; i++) {
                    const crackleOsc = audioContext.createOscillator();
                    const crackleGain = audioContext.createGain();
                    
                    crackleOsc.connect(crackleGain);
                    crackleGain.connect(audioContext.destination);
                    
                    crackleOsc.frequency.value = 200 + Math.random() * 300; // Random high frequencies
                    crackleOsc.type = 'triangle';
                    
                    const crackleStart = startTime + 0.3 + (i * 0.2);
                    const crackleDuration = 0.15 + Math.random() * 0.2;
                    
                    crackleGain.gain.setValueAtTime(0.05, crackleStart);
                    crackleGain.gain.exponentialRampToValueAtTime(0.01, crackleStart + crackleDuration);
                    
                    crackleOsc.start(crackleStart);
                    crackleOsc.stop(crackleStart + crackleDuration);
                }
                
                // Final echo/reverb effect
                const echoOsc = audioContext.createOscillator();
                const echoGain = audioContext.createGain();
                
                echoOsc.connect(echoGain);
                echoGain.connect(audioContext.destination);
                
                echoOsc.frequency.value = 100;
                echoOsc.type = 'sine';
                
                echoGain.gain.setValueAtTime(0, startTime + 1.5);
                echoGain.gain.linearRampToValueAtTime(0.08, startTime + 1.8);
                echoGain.gain.exponentialRampToValueAtTime(0.01, startTime + duration);
                
                echoOsc.start(startTime + 1.5);
                echoOsc.stop(startTime + duration);
            },
            chicken: () => {
                // Create chicken sound with multiple frequencies to simulate clucking
                const startTime = audioContext.currentTime;
                const duration = 0.3;
                
                // Main cluck sound
                const oscillator1 = audioContext.createOscillator();
                const gain1 = audioContext.createGain();
                oscillator1.connect(gain1);
                gain1.connect(audioContext.destination);
                
                oscillator1.frequency.setValueAtTime(300, startTime);
                oscillator1.frequency.exponentialRampToValueAtTime(150, startTime + 0.1);
                oscillator1.type = 'square';
                
                gain1.gain.setValueAtTime(0.3, startTime);
                gain1.gain.exponentialRampToValueAtTime(0.01, startTime + duration);
                
                oscillator1.start(startTime);
                oscillator1.stop(startTime + duration);
                
                // Second cluck for harmony
                const oscillator2 = audioContext.createOscillator();
                const gain2 = audioContext.createGain();
                oscillator2.connect(gain2);
                gain2.connect(audioContext.destination);
                
                oscillator2.frequency.setValueAtTime(450, startTime + 0.05);
                oscillator2.frequency.exponentialRampToValueAtTime(200, startTime + 0.15);
                oscillator2.type = 'triangle';
                
                gain2.gain.setValueAtTime(0.2, startTime + 0.05);
                gain2.gain.exponentialRampToValueAtTime(0.01, startTime + duration);
                
                oscillator2.start(startTime + 0.05);
                oscillator2.stop(startTime + duration);
            },
            bossEntrance: () => {
                const startTime = audioContext.currentTime;
                
                // Boss musical phrase - dramatic ascending notes
                const notes = [100, 130, 164, 200, 260]; // Bass to mid range
                const noteDuration = 0.4;
                
                notes.forEach((frequency, index) => {
                    const noteStart = startTime + (index * 0.3);
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    oscillator.type = 'sawtooth'; // Dramatic sound
                    
                    // Dramatic volume envelope
                    gainNode.gain.setValueAtTime(0, noteStart);
                    gainNode.gain.linearRampToValueAtTime(0.25, noteStart + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, noteStart + noteDuration);
                    
                    oscillator.start(noteStart);
                    oscillator.stop(noteStart + noteDuration);
                });
                
                // Add explosion at the end
                setTimeout(() => {
                    sounds.bossExplosion();
                }, 1500); // After musical phrase completes
            },
            bossExplosion: () => {
                const startTime = audioContext.currentTime;
                const duration = 1.0;
                
                // Create explosive entrance sound
                const explosion = audioContext.createOscillator();
                const explosionGain = audioContext.createGain();
                
                explosion.connect(explosionGain);
                explosionGain.connect(audioContext.destination);
                
                explosion.frequency.value = 60;
                explosion.type = 'sawtooth';
                
                // Sharp explosion attack
                explosionGain.gain.setValueAtTime(0.4, startTime);
                explosionGain.gain.exponentialRampToValueAtTime(0.01, startTime + duration);
                
                explosion.start(startTime);
                explosion.stop(startTime + duration);
                
                // Add some crackling effects
                for (let i = 0; i < 4; i++) {
                    const crackle = audioContext.createOscillator();
                    const crackleGain = audioContext.createGain();
                    
                    crackle.connect(crackleGain);
                    crackleGain.connect(audioContext.destination);
                    
                    crackle.frequency.value = 150 + Math.random() * 200;
                    crackle.type = 'square';
                    
                    const crackleStart = startTime + (i * 0.1);
                    const crackleDuration = 0.15;
                    
                    crackleGain.gain.setValueAtTime(0.1, crackleStart);
                    crackleGain.gain.exponentialRampToValueAtTime(0.01, crackleStart + crackleDuration);
                    
                    crackle.start(crackleStart);
                    crackle.stop(crackleStart + crackleDuration);
                }
            }
        };

        // Sprite definitions using SVG
        const sprites = {
            chicken: `
                <svg width="100" height="80" viewBox="0 0 100 80">
                    <!-- Chicken head -->
                    <rect x="35" y="10" width="30" height="25" fill="#FFFFFF"/>
                    <rect x="30" y="15" width="40" height="15" fill="#F0F0F0"/>
                    <!-- Beak -->
                    <rect x="25" y="20" width="10" height="8" fill="#FFA500"/>
                    <rect x="20" y="22" width="8" height="4" fill="#FF8C00"/>
                    <!-- Eye -->
                    <rect x="47" y="18" width="6" height="6" fill="#000000"/>
                    <rect x="49" y="20" width="2" height="2" fill="#FFFFFF"/>
                    <!-- Comb (red crest on top) -->
                    <rect x="42" y="5" width="6" height="8" fill="#DC143C"/>
                    <rect x="48" y="3" width="6" height="10" fill="#DC143C"/>
                    <rect x="54" y="5" width="6" height="8" fill="#DC143C"/>
                    <!-- Wattles (red things under beak) -->
                    <rect x="30" y="28" width="4" height="6" fill="#DC143C"/>
                    <rect x="66" y="28" width="4" height="6" fill="#DC143C"/>
                    <!-- Body -->
                    <rect x="25" y="35" width="50" height="30" fill="#FFFFFF"/>
                    <rect x="20" y="40" width="60" height="20" fill="#F5F5F5"/>
                    <!-- Wings -->
                    <rect x="15" y="42" width="15" height="16" fill="#E0E0E0"/>
                    <rect x="70" y="42" width="15" height="16" fill="#E0E0E0"/>
                    <!-- Tail feathers -->
                    <rect x="75" y="35" width="20" height="25" fill="#DCDCDC"/>
                    <rect x="80" y="30" width="15" height="20" fill="#FFFFFF"/>
                    <!-- Legs -->
                    <rect x="38" y="65" width="6" height="12" fill="#FFA500"/>
                    <rect x="56" y="65" width="6" height="12" fill="#FFA500"/>
                    <!-- Feet -->
                    <rect x="32" y="75" width="18" height="4" fill="#FF8C00"/>
                    <rect x="50" y="75" width="18" height="4" fill="#FF8C00"/>
                </svg>
            `,
            zombie: `
                <svg width="60" height="60" viewBox="0 0 60 60">
                    <!-- Head -->
                    <rect x="15" y="5" width="30" height="25" fill="#7cb518"/>
                    <rect x="12" y="8" width="36" height="19" fill="#6ca017"/>
                    <!-- Face -->
                    <rect x="20" y="12" width="6" height="6" fill="#000"/>
                    <rect x="34" y="12" width="6" height="6" fill="#000"/>
                    <rect x="22" y="14" width="2" height="2" fill="#ff0000"/>
                    <rect x="36" y="14" width="2" height="2" fill="#ff0000"/>
                    <rect x="24" y="20" width="12" height="4" fill="#654321"/>
                    <rect x="26" y="22" width="2" height="2" fill="#fff"/>
                    <rect x="30" y="22" width="2" height="2" fill="#fff"/>
                    <rect x="34" y="22" width="2" height="2" fill="#fff"/>
                    <!-- Body -->
                    <rect x="18" y="30" width="24" height="20" fill="#3366cc"/>
                    <rect x="15" y="33" width="30" height="14" fill="#2d5ab8"/>
                    <!-- Arms -->
                    <rect x="6" y="32" width="12" height="18" fill="#7cb518"/>
                    <rect x="42" y="32" width="12" height="18" fill="#7cb518"/>
                    <!-- Legs -->
                    <rect x="20" y="50" width="8" height="10" fill="#654321"/>
                    <rect x="32" y="50" width="8" height="10" fill="#654321"/>
                </svg>
            `,
            creeper: `
                <svg width="60" height="60" viewBox="0 0 60 60">
                    <!-- Body -->
                    <rect x="15" y="10" width="30" height="50" fill="#0da70b"/>
                    <rect x="12" y="12" width="36" height="46" fill="#0b8f09"/>
                    <!-- Face -->
                    <rect x="18" y="16" width="6" height="6" fill="#000"/>
                    <rect x="36" y="16" width="6" height="6" fill="#000"/>
                    <rect x="20" y="18" width="2" height="2" fill="#333"/>
                    <rect x="38" y="18" width="2" height="2" fill="#333"/>
                    <!-- Mouth pattern -->
                    <rect x="24" y="24" width="6" height="6" fill="#000"/>
                    <rect x="30" y="24" width="6" height="6" fill="#000"/>
                    <rect x="27" y="30" width="6" height="10" fill="#000"/>
                    <!-- Texture details -->
                    <rect x="18" y="40" width="6" height="2" fill="#085c07"/>
                    <rect x="36" y="40" width="6" height="2" fill="#085c07"/>
                    <rect x="24" y="45" width="12" height="2" fill="#085c07"/>
                    <!-- Legs -->
                    <rect x="12" y="50" width="12" height="10" fill="#0da70b"/>
                    <rect x="36" y="50" width="12" height="10" fill="#0da70b"/>
                </svg>
            `,
            skeleton: `
                <svg width="60" height="60" viewBox="0 0 60 60">
                    <!-- Head -->
                    <rect x="18" y="5" width="24" height="20" fill="#f5f5dc"/>
                    <rect x="15" y="8" width="30" height="14" fill="#ede5c8"/>
                    <!-- Face -->
                    <rect x="22" y="12" width="4" height="6" fill="#000"/>
                    <rect x="34" y="12" width="4" height="6" fill="#000"/>
                    <rect x="24" y="14" width="2" height="2" fill="#333"/>
                    <rect x="36" y="14" width="2" height="2" fill="#333"/>
                    <rect x="26" y="18" width="8" height="3" fill="#000"/>
                    <rect x="28" y="19" width="1" height="1" fill="#f5f5dc"/>
                    <rect x="31" y="19" width="1" height="1" fill="#f5f5dc"/>
                    <!-- Body -->
                    <rect x="21" y="25" width="18" height="25" fill="#ddd"/>
                    <rect x="18" y="28" width="24" height="19" fill="#ccc"/>
                    <!-- Ribs -->
                    <rect x="24" y="30" width="12" height="2" fill="#aaa"/>
                    <rect x="24" y="34" width="12" height="2" fill="#aaa"/>
                    <rect x="24" y="38" width="12" height="2" fill="#aaa"/>
                    <!-- Arms -->
                    <rect x="9" y="27" width="12" height="15" fill="#ddd"/>
                    <rect x="39" y="27" width="12" height="15" fill="#ddd"/>
                    <!-- Legs -->
                    <rect x="22" y="50" width="6" height="10" fill="#ddd"/>
                    <rect x="32" y="50" width="6" height="10" fill="#ddd"/>
                </svg>
            `,
            witch: `
                <svg width="90" height="90" viewBox="0 0 90 90">
                    <!-- Hat -->
                    <rect x="30" y="0" width="30" height="25" fill="#654321"/>
                    <rect x="25" y="20" width="40" height="8" fill="#654321"/>
                    <rect x="50" y="0" width="15" height="5" fill="#8B4513"/>
                    <!-- Head -->
                    <rect x="25" y="20" width="40" height="30" fill="#228B22"/>
                    <rect x="20" y="25" width="50" height="20" fill="#32CD32"/>
                    <!-- Eyes -->
                    <rect x="32" y="30" width="6" height="8" fill="#000"/>
                    <rect x="52" y="30" width="6" height="8" fill="#000"/>
                    <rect x="34" y="32" width="2" height="4" fill="#ff0000"/>
                    <rect x="54" y="32" width="2" height="4" fill="#ff0000"/>
                    <!-- Nose -->
                    <rect x="42" y="36" width="6" height="10" fill="#32CD32"/>
                    <rect x="44" y="38" width="4" height="6" fill="#228B22"/>
                    <!-- Mouth -->
                    <rect x="38" y="44" width="14" height="4" fill="#000"/>
                    <rect x="40" y="46" width="2" height="2" fill="#fff"/>
                    <rect x="48" y="46" width="2" height="2" fill="#fff"/>
                    <!-- Body -->
                    <rect x="25" y="50" width="40" height="40" fill="#8A2BE2"/>
                    <rect x="20" y="55" width="50" height="30" fill="#9932CC"/>
                    <!-- Arms -->
                    <rect x="5" y="55" width="20" height="25" fill="#228B22"/>
                    <rect x="65" y="55" width="20" height="25" fill="#228B22"/>
                    <!-- Cauldron -->
                    <rect x="70" y="70" width="15" height="12" fill="#2F4F4F"/>
                    <rect x="72" y="72" width="11" height="8" fill="#00FF00" opacity="0.7"/>
                </svg>
            `,
            evoker: `
                <svg width="90" height="90" viewBox="0 0 90 90">
                    <!-- Hood -->
                    <rect x="20" y="5" width="50" height="40" fill="#4B0082"/>
                    <rect x="15" y="10" width="60" height="30" fill="#6A0DAD"/>
                    <!-- Face (partially hidden) -->
                    <rect x="35" y="25" width="20" height="20" fill="#F5DEB3"/>
                    <rect x="30" y="30" width="30" height="10" fill="#DDD"/>
                    <!-- Eyes (glowing) -->
                    <rect x="38" y="32" width="4" height="6" fill="#00FFFF"/>
                    <rect x="48" y="32" width="4" height="6" fill="#00FFFF"/>
                    <rect x="39" y="33" width="2" height="4" fill="#FFFFFF"/>
                    <rect x="49" y="33" width="2" height="4" fill="#FFFFFF"/>
                    <!-- Body -->
                    <rect x="25" y="45" width="40" height="45" fill="#4B0082"/>
                    <rect x="20" y="50" width="50" height="35" fill="#6A0DAD"/>
                    <!-- Robe details -->
                    <rect x="30" y="55" width="30" height="3" fill="#FFD700"/>
                    <rect x="32" y="65" width="26" height="2" fill="#FFD700"/>
                    <rect x="34" y="75" width="22" height="2" fill="#FFD700"/>
                    <!-- Arms -->
                    <rect x="5" y="50" width="20" height="30" fill="#4B0082"/>
                    <rect x="65" y="50" width="20" height="30" fill="#4B0082"/>
                    <!-- Staff -->
                    <rect x="85" y="20" width="3" height="50" fill="#8B4513"/>
                    <rect x="82" y="18" width="9" height="6" fill="#FFD700"/>
                    <!-- Magic particles -->
                    <rect x="10" y="15" width="3" height="3" fill="#FF00FF" opacity="0.8"/>
                    <rect x="75" y="25" width="3" height="3" fill="#00FFFF" opacity="0.8"/>
                    <rect x="15" y="35" width="2" height="2" fill="#FFD700" opacity="0.8"/>
                </svg>
            `,
            ravager: `
                <svg width="120" height="90" viewBox="0 0 120 90">
                    <!-- Head -->
                    <rect x="30" y="10" width="60" height="35" fill="#696969"/>
                    <rect x="25" y="15" width="70" height="25" fill="#808080"/>
                    <!-- Horns -->
                    <rect x="20" y="5" width="8" height="20" fill="#2F2F2F"/>
                    <rect x="92" y="5" width="8" height="20" fill="#2F2F2F"/>
                    <rect x="18" y="3" width="4" height="10" fill="#1C1C1C"/>
                    <rect x="98" y="3" width="4" height="10" fill="#1C1C1C"/>
                    <!-- Eyes -->
                    <rect x="40" y="22" width="8" height="10" fill="#ff0000"/>
                    <rect x="72" y="22" width="8" height="10" fill="#ff0000"/>
                    <rect x="42" y="24" width="4" height="6" fill="#FFFF00"/>
                    <rect x="74" y="24" width="4" height="6" fill="#FFFF00"/>
                    <!-- Mouth -->
                    <rect x="50" y="32" width="20" height="8" fill="#000"/>
                    <rect x="48" y="34" width="4" height="4" fill="#fff"/>
                    <rect x="68" y="34" width="4" height="4" fill="#fff"/>
                    <!-- Body -->
                    <rect x="20" y="45" width="80" height="35" fill="#696969"/>
                    <rect x="15" y="50" width="90" height="25" fill="#808080"/>
                    <!-- Legs -->
                    <rect x="25" y="75" width="15" height="15" fill="#2F2F2F"/>
                    <rect x="50" y="75" width="15" height="15" fill="#2F2F2F"/>
                    <rect x="70" y="75" width="15" height="15" fill="#2F2F2F"/>
                    <rect x="95" y="75" width="15" height="15" fill="#2F2F2F"/>
                    <!-- Saddle -->
                    <rect x="35" y="45" width="50" height="8" fill="#8B4513"/>
                    <rect x="40" y="40" width="40" height="5" fill="#654321"/>
                    <!-- Armor spikes -->
                    <rect x="30" y="38" width="5" height="10" fill="#2F2F2F"/>
                    <rect x="85" y="38" width="5" height="10" fill="#2F2F2F"/>
                </svg>
            `,
            warden: `
                <svg width="100" height="120" viewBox="0 0 100 120">
                    <!-- Head -->
                    <rect x="20" y="10" width="60" height="40" fill="#0F0F23"/>
                    <rect x="15" y="15" width="70" height="30" fill="#1C1C3A"/>
                    <!-- Horns/Antlers -->
                    <rect x="10" y="5" width="6" height="25" fill="#36454F"/>
                    <rect x="84" y="5" width="6" height="25" fill="#36454F"/>
                    <rect x="8" y="0" width="10" height="12" fill="#2F4F4F"/>
                    <rect x="82" y="0" width="10" height="12" fill="#2F4F4F"/>
                    <!-- Glowing heart -->
                    <rect x="40" y="25" width="20" height="15" fill="#00FFFF"/>
                    <rect x="42" y="27" width="16" height="11" fill="#87CEEB"/>
                    <rect x="45" y="30" width="10" height="5" fill="#FFFFFF"/>
                    <!-- Soul fire effects -->
                    <rect x="25" y="20" width="3" height="6" fill="#00FFFF" opacity="0.7"/>
                    <rect x="72" y="22" width="3" height="6" fill="#00FFFF" opacity="0.7"/>
                    <rect x="35" y="15" width="2" height="4" fill="#87CEEB" opacity="0.8"/>
                    <rect x="63" y="18" width="2" height="4" fill="#87CEEB" opacity="0.8"/>
                    <!-- Body -->
                    <rect x="15" y="50" width="70" height="50" fill="#0F0F23"/>
                    <rect x="10" y="55" width="80" height="40" fill="#1C1C3A"/>
                    <!-- Chest sculk -->
                    <rect x="35" y="60" width="30" height="25" fill="#36454F"/>
                    <rect x="38" y="63" width="24" height="19" fill="#4682B4"/>
                    <rect x="42" y="67" width="16" height="11" fill="#00FFFF" opacity="0.6"/>
                    <!-- Arms -->
                    <rect x="0" y="55" width="15" height="40" fill="#0F0F23"/>
                    <rect x="85" y="55" width="15" height="40" fill="#0F0F23"/>
                    <!-- Legs -->
                    <rect x="25" y="100" width="18" height="20" fill="#0F0F23"/>
                    <rect x="57" y="100" width="18" height="20" fill="#0F0F23"/>
                    <!-- Sculk tendrils -->
                    <rect x="5" y="45" width="4" height="15" fill="#36454F"/>
                    <rect x="91" y="48" width="4" height="15" fill="#36454F"/>
                    <rect x="45" y="45" width="10" height="3" fill="#4682B4" opacity="0.7"/>
                </svg>
            `,
            egg: `
                <svg width="16" height="24" viewBox="0 0 16 24">
                    <!-- Egg body -->
                    <rect x="4" y="4" width="8" height="16" fill="#F5F5DC"/>
                    <rect x="3" y="6" width="10" height="12" fill="#FFFEF7"/>
                    <rect x="5" y="2" width="6" height="4" fill="#F0F0F0"/>
                    <rect x="5" y="18" width="6" height="4" fill="#F0F0F0"/>
                    <!-- Egg highlights -->
                    <rect x="6" y="6" width="4" height="8" fill="#FFFFFF" opacity="0.6"/>
                    <rect x="7" y="8" width="2" height="4" fill="#FFFFFF" opacity="0.8"/>
                    <!-- Small speckles -->
                    <rect x="5" y="10" width="1" height="1" fill="#DDD"/>
                    <rect x="10" y="12" width="1" height="1" fill="#DDD"/>
                    <rect x="7" y="14" width="1" height="1" fill="#DDD"/>
                </svg>
            `,
            snowball: `
                <svg width="20" height="20" viewBox="0 0 20 20">
                    <rect x="4" y="4" width="12" height="12" fill="#ffffff"/>
                    <rect x="6" y="2" width="8" height="8" fill="#f0f0f0"/>
                    <rect x="2" y="6" width="8" height="8" fill="#f0f0f0"/>
                    <rect x="10" y="6" width="8" height="8" fill="#f0f0f0"/>
                    <rect x="6" y="10" width="8" height="8" fill="#f0f0f0"/>
                    <!-- Snow texture -->
                    <rect x="8" y="8" width="4" height="4" fill="#e8e8e8"/>
                    <rect x="6" y="6" width="2" height="2" fill="#ddd"/>
                    <rect x="12" y="12" width="2" height="2" fill="#ddd"/>
                </svg>
            `,
            diamondSword: `
                <svg width="40" height="40" viewBox="0 0 40 40">
                    <rect x="18" y="4" width="4" height="24" fill="#8B4513"/>
                    <rect x="16" y="28" width="8" height="4" fill="#654321"/>
                    <rect x="14" y="2" width="12" height="20" fill="#87CEEB"/>
                    <rect x="16" y="0" width="8" height="4" fill="#B0E0E6"/>
                    <rect x="18" y="6" width="4" height="12" fill="#E0FFFF"/>
                </svg>
            `,
            goldenApple: `
                <svg width="40" height="40" viewBox="0 0 40 40">
                    <rect x="16" y="8" width="8" height="24" fill="#FFD700"/>
                    <rect x="12" y="12" width="16" height="16" fill="#FFA500"/>
                    <rect x="18" y="4" width="4" height="8" fill="#228B22"/>
                    <rect x="14" y="14" width="12" height="12" fill="#FFFF00" opacity="0.7"/>
                    <rect x="20" y="10" width="4" height="4" fill="#ADFF2F"/>
                </svg>
            `,
            enderPearl: `
                <svg width="40" height="40" viewBox="0 0 40 40">
                    <rect x="12" y="12" width="16" height="16" fill="#2F2F4F"/>
                    <rect x="14" y="10" width="12" height="20" fill="#483D8B"/>
                    <rect x="16" y="8" width="8" height="24" fill="#6A5ACD"/>
                    <rect x="18" y="14" width="4" height="12" fill="#9370DB" opacity="0.8"/>
                    <rect x="10" y="18" width="2" height="2" fill="#DDA0DD" opacity="0.6"/>
                    <rect x="28" y="22" width="2" height="2" fill="#DDA0DD" opacity="0.6"/>
                </svg>
            `,
            fireball: `
                <svg width="40" height="40" viewBox="0 0 40 40">
                    <!-- Core fire -->
                    <circle cx="20" cy="20" r="16" fill="#FF4500"/>
                    <circle cx="20" cy="20" r="12" fill="#FF6600"/>
                    <circle cx="20" cy="20" r="8" fill="#FF8800"/>
                    <circle cx="20" cy="20" r="4" fill="#FFAA00"/>
                    <!-- Fire particles -->
                    <circle cx="15" cy="10" r="2" fill="#FF4500" opacity="0.8"/>
                    <circle cx="25" cy="8" r="1.5" fill="#FF6600" opacity="0.7"/>
                    <circle cx="30" cy="15" r="2" fill="#FF4500" opacity="0.6"/>
                    <circle cx="8" cy="25" r="1.5" fill="#FF8800" opacity="0.7"/>
                    <circle cx="32" cy="30" r="1" fill="#FFAA00" opacity="0.8"/>
                    <!-- Hot center -->
                    <circle cx="20" cy="20" r="2" fill="#FFFFFF" opacity="0.9"/>
                </svg>
            `,
            firePotion: `
                <svg width="40" height="40" viewBox="0 0 40 40">
                    <rect x="14" y="8" width="12" height="24" fill="#8B4513"/>
                    <rect x="16" y="10" width="8" height="20" fill="#FF4500"/>
                    <rect x="18" y="12" width="4" height="16" fill="#FF6347"/>
                    <rect x="16" y="4" width="8" height="8" fill="#696969"/>
                    <rect x="18" y="6" width="4" height="4" fill="#A9A9A9"/>
                    <rect x="20" y="14" width="2" height="2" fill="#FFFF00" opacity="0.8"/>
                </svg>
            `,
            totem: `
                <svg width="40" height="40" viewBox="0 0 40 40">
                    <rect x="16" y="8" width="8" height="24" fill="#FFD700"/>
                    <rect x="12" y="12" width="16" height="16" fill="#FFA500"/>
                    <rect x="14" y="4" width="12" height="8" fill="#32CD32"/>
                    <rect x="18" y="2" width="4" height="6" fill="#228B22"/>
                    <rect x="18" y="14" width="4" height="12" fill="#FFFF00" opacity="0.7"/>
                    <rect x="10" y="16" width="4" height="8" fill="#FFD700"/>
                    <rect x="26" y="16" width="4" height="8" fill="#FFD700"/>
                </svg>
            `,
            redstone: `
                <svg width="40" height="40" viewBox="0 0 40 40">
                    <rect x="14" y="14" width="12" height="12" fill="#DC143C"/>
                    <rect x="16" y="12" width="8" height="16" fill="#FF0000"/>
                    <rect x="12" y="16" width="16" height="8" fill="#B22222"/>
                    <rect x="18" y="18" width="4" height="4" fill="#FF6347" opacity="0.8"/>
                    <rect x="8" y="20" width="2" height="2" fill="#FF0000" opacity="0.6"/>
                    <rect x="30" y="18" width="2" height="2" fill="#FF0000" opacity="0.6"/>
                    <rect x="20" y="8" width="2" height="2" fill="#FF0000" opacity="0.6"/>
                </svg>
            `,
            tnt: `
                <svg width="40" height="40" viewBox="0 0 40 40">
                    <rect x="8" y="8" width="24" height="24" fill="#DC143C"/>
                    <rect x="10" y="10" width="20" height="20" fill="#FF0000"/>
                    <rect x="12" y="12" width="16" height="16" fill="#8B0000"/>
                    <rect x="14" y="18" width="12" height="4" fill="#FFFFFF"/>
                    <rect x="18" y="14" width="4" height="12" fill="#FFFFFF"/>
                    <rect x="16" y="4" width="8" height="8" fill="#228B22"/>
                    <rect x="20" y="2" width="2" height="6" fill="#000000"/>
                </svg>
            `,
            blazeRod: `
                <svg width="40" height="40" viewBox="0 0 40 40">
                    <rect x="18" y="4" width="4" height="32" fill="#8B4513"/>
                    <rect x="16" y="6" width="8" height="28" fill="#DAA520"/>
                    <rect x="14" y="8" width="12" height="24" fill="#FF8C00"/>
                    <rect x="16" y="10" width="8" height="20" fill="#FF4500"/>
                    <rect x="18" y="12" width="4" height="16" fill="#FF0000"/>
                    <!-- Fire particles -->
                    <rect x="12" y="14" width="2" height="2" fill="#FFD700" opacity="0.8"/>
                    <rect x="26" y="18" width="2" height="2" fill="#FFD700" opacity="0.8"/>
                    <rect x="10" y="22" width="2" height="2" fill="#FF6347" opacity="0.7"/>
                    <rect x="28" y="26" width="2" height="2" fill="#FF6347" opacity="0.7"/>
                </svg>
            `,
            stevesLavaChicken: `
                <svg width="40" height="40" viewBox="0 0 40 40">
                    <!-- Lava Chicken Body -->
                    <rect x="10" y="15" width="20" height="15" fill="#FF4500"/>
                    <rect x="8" y="17" width="24" height="11" fill="#FF6347"/>
                    <!-- Chicken Head -->
                    <rect x="14" y="8" width="12" height="10" fill="#FFD700"/>
                    <rect x="12" y="10" width="16" height="6" fill="#FFA500"/>
                    <!-- Lava Eyes -->
                    <rect x="16" y="11" width="2" height="2" fill="#FF0000"/>
                    <rect x="22" y="11" width="2" height="2" fill="#FF0000"/>
                    <!-- Molten Beak -->
                    <rect x="10" y="12" width="4" height="3" fill="#FF8C00"/>
                    <!-- Lava Comb -->
                    <rect x="16" y="4" width="2" height="6" fill="#DC143C"/>
                    <rect x="18" y="2" width="2" height="8" fill="#DC143C"/>
                    <rect x="20" y="4" width="2" height="6" fill="#DC143C"/>
                    <!-- Molten Wings -->
                    <rect x="6" y="18" width="6" height="8" fill="#FF8C00"/>
                    <rect x="28" y="18" width="6" height="8" fill="#FF8C00"/>
                    <!-- Lava Tail -->
                    <rect x="30" y="15" width="8" height="10" fill="#FF4500"/>
                    <rect x="32" y="12" width="6" height="8" fill="#FFD700"/>
                    <!-- Lava Legs -->
                    <rect x="15" y="30" width="3" height="6" fill="#8B4513"/>
                    <rect x="22" y="30" width="3" height="6" fill="#8B4513"/>
                    <!-- Lava Feet -->
                    <rect x="13" y="35" width="7" height="2" fill="#FF8C00"/>
                    <rect x="20" y="35" width="7" height="2" fill="#FF8C00"/>
                    <!-- Lava Particles -->
                    <rect x="5" y="8" width="1" height="1" fill="#FF0000" opacity="0.8"/>
                    <rect x="34" y="10" width="1" height="1" fill="#FF0000" opacity="0.8"/>
                    <rect x="8" y="25" width="1" height="1" fill="#FFD700" opacity="0.7"/>
                    <rect x="31" y="28" width="1" height="1" fill="#FFD700" opacity="0.7"/>
                </svg>
            `,
            tractorBeam: `
                <svg width="60" height="100" viewBox="0 0 60 100">
                    <!-- Tractor beam effect -->
                    <rect x="10" y="0" width="40" height="20" fill="#9370DB" opacity="0.3"/>
                    <rect x="8" y="20" width="44" height="20" fill="#8A2BE2" opacity="0.3"/>
                    <rect x="6" y="40" width="48" height="20" fill="#9932CC" opacity="0.3"/>
                    <rect x="4" y="60" width="52" height="20" fill="#BA55D3" opacity="0.3"/>
                    <rect x="2" y="80" width="56" height="20" fill="#DDA0DD" opacity="0.3"/>
                    <!-- Beam particles -->
                    <rect x="15" y="10" width="2" height="2" fill="#FFFFFF" opacity="0.8"/>
                    <rect x="43" y="25" width="2" height="2" fill="#FFFFFF" opacity="0.8"/>
                    <rect x="20" y="45" width="2" height="2" fill="#FFFFFF" opacity="0.8"/>
                    <rect x="35" y="65" width="2" height="2" fill="#FFFFFF" opacity="0.8"/>
                    <rect x="28" y="85" width="2" height="2" fill="#FFFFFF" opacity="0.8"/>
                </svg>
            `,
            fireSpread: `
                <svg width="24" height="24" viewBox="0 0 24 24">
                    <rect x="8" y="4" width="8" height="16" fill="#FF4500"/>
                    <rect x="6" y="6" width="12" height="12" fill="#FF6347"/>
                    <rect x="4" y="8" width="16" height="8" fill="#FF8C00"/>
                    <rect x="10" y="2" width="4" height="20" fill="#FFD700"/>
                    <rect x="12" y="0" width="2" height="24" fill="#FFFF00" opacity="0.8"/>
                    <!-- Animated flicker effect -->
                    <rect x="2" y="10" width="2" height="4" fill="#FF0000" opacity="0.6"/>
                    <rect x="20" y="8" width="2" height="6" fill="#FF0000" opacity="0.6"/>
                </svg>
            `,
            shield: `
                <svg width="40" height="40" viewBox="0 0 40 40">
                    <!-- Shield Base -->
                    <path d="M20 2 L30 10 L30 25 L20 38 L10 25 L10 10 Z" fill="#4A90E2" stroke="#2C5A80" stroke-width="2"/>
                    <!-- Shield Highlight -->
                    <path d="M20 4 L28 11 L28 24 L20 35 L12 24 L12 11 Z" fill="#5BA0F2" opacity="0.8"/>
                    <!-- Shield Center Gem -->
                    <circle cx="20" cy="18" r="4" fill="#FFD700" stroke="#FFA500" stroke-width="1"/>
                    <!-- Shield Decorative Lines -->
                    <line x1="15" y1="12" x2="25" y2="12" stroke="#FFFFFF" stroke-width="1" opacity="0.6"/>
                    <line x1="14" y1="16" x2="26" y2="16" stroke="#FFFFFF" stroke-width="1" opacity="0.4"/>
                    <line x1="14" y1="24" x2="26" y2="24" stroke="#FFFFFF" stroke-width="1" opacity="0.4"/>
                    <!-- Shield Glow Effect -->
                    <path d="M20 2 L30 10 L30 25 L20 38 L10 25 L10 10 Z" fill="none" stroke="#87CEEB" stroke-width="1" opacity="0.7"/>
                </svg>
            `,
            iceBlock: `
                <svg width="40" height="40" viewBox="0 0 40 40">
                    <!-- Ice Block Base -->
                    <rect x="6" y="6" width="28" height="28" fill="#B0E0E6" stroke="#4682B4" stroke-width="2"/>
                    <!-- Ice Block Highlight -->
                    <rect x="8" y="8" width="24" height="24" fill="#E0F6FF" opacity="0.8"/>
                    <!-- Ice Crystals -->
                    <polygon points="20,10 22,14 18,14" fill="#FFFFFF" opacity="0.9"/>
                    <polygon points="20,30 22,26 18,26" fill="#FFFFFF" opacity="0.9"/>
                    <polygon points="10,20 14,22 14,18" fill="#FFFFFF" opacity="0.9"/>
                    <polygon points="30,20 26,22 26,18" fill="#FFFFFF" opacity="0.9"/>
                    <!-- Ice Sparkles -->
                    <circle cx="15" cy="15" r="1" fill="#FFFFFF" opacity="0.8"/>
                    <circle cx="25" cy="15" r="1" fill="#FFFFFF" opacity="0.8"/>
                    <circle cx="15" cy="25" r="1" fill="#FFFFFF" opacity="0.8"/>
                    <circle cx="25" cy="25" r="1" fill="#FFFFFF" opacity="0.8"/>
                    <circle cx="20" cy="20" r="1.5" fill="#FFFFFF" opacity="1"/>
                    <!-- Ice Shine Effect -->
                    <rect x="10" y="8" width="4" height="2" fill="#FFFFFF" opacity="0.6"/>
                    <rect x="26" y="12" width="2" height="4" fill="#FFFFFF" opacity="0.6"/>
                </svg>
            `,
            piglin: `
                <svg width="60" height="60" viewBox="0 0 60 60">
                    <!-- Head -->
                    <rect x="15" y="5" width="30" height="25" fill="#F4A460"/>
                    <rect x="12" y="8" width="36" height="19" fill="#DEB887"/>
                    <!-- Snout -->
                    <rect x="24" y="18" width="12" height="8" fill="#D2691E"/>
                    <rect x="26" y="20" width="2" height="2" fill="#000"/>
                    <rect x="32" y="20" width="2" height="2" fill="#000"/>
                    <!-- Eyes -->
                    <rect x="20" y="12" width="6" height="6" fill="#FF4500"/>
                    <rect x="34" y="12" width="6" height="6" fill="#FF4500"/>
                    <rect x="22" y="14" width="2" height="2" fill="#000"/>
                    <rect x="36" y="14" width="2" height="2" fill="#000"/>
                    <!-- Ears -->
                    <rect x="10" y="10" width="8" height="12" fill="#F4A460"/>
                    <rect x="42" y="10" width="8" height="12" fill="#F4A460"/>
                    <!-- Body -->
                    <rect x="18" y="30" width="24" height="20" fill="#8B4513"/>
                    <rect x="15" y="33" width="30" height="14" fill="#A0522D"/>
                    <!-- Arms -->
                    <rect x="6" y="32" width="12" height="18" fill="#F4A460"/>
                    <rect x="42" y="32" width="12" height="18" fill="#F4A460"/>
                    <!-- Legs -->
                    <rect x="20" y="50" width="8" height="10" fill="#8B4513"/>
                    <rect x="32" y="50" width="8" height="10" fill="#8B4513"/>
                </svg>
            `,
            zombie_piglin: `
                <svg width="60" height="60" viewBox="0 0 60 60">
                    <!-- Head -->
                    <rect x="15" y="5" width="30" height="25" fill="#228B22"/>
                    <rect x="12" y="8" width="36" height="19" fill="#32CD32"/>
                    <!-- Snout -->
                    <rect x="24" y="18" width="12" height="8" fill="#8B4513"/>
                    <rect x="26" y="20" width="2" height="2" fill="#000"/>
                    <rect x="32" y="20" width="2" height="2" fill="#000"/>
                    <!-- Eyes -->
                    <rect x="20" y="12" width="6" height="6" fill="#8B0000"/>
                    <rect x="34" y="12" width="6" height="6" fill="#8B0000"/>
                    <rect x="22" y="14" width="2" height="2" fill="#FF0000"/>
                    <rect x="36" y="14" width="2" height="2" fill="#FF0000"/>
                    <!-- Ears -->
                    <rect x="10" y="10" width="8" height="12" fill="#228B22"/>
                    <rect x="42" y="10" width="8" height="12" fill="#228B22"/>
                    <!-- Body -->
                    <rect x="18" y="30" width="24" height="20" fill="#8B4513"/>
                    <rect x="15" y="33" width="30" height="14" fill="#A0522D"/>
                    <!-- Arms -->
                    <rect x="6" y="32" width="12" height="18" fill="#228B22"/>
                    <rect x="42" y="32" width="12" height="18" fill="#228B22"/>
                    <!-- Legs -->
                    <rect x="20" y="50" width="8" height="10" fill="#8B4513"/>
                    <rect x="32" y="50" width="8" height="10" fill="#8B4513"/>
                    <!-- Rotting effects -->
                    <rect x="18" y="40" width="6" height="2" fill="#654321"/>
                    <rect x="36" y="42" width="6" height="2" fill="#654321"/>
                </svg>
            `,
            wither_skeleton: `
                <svg width="60" height="60" viewBox="0 0 60 60">
                    <!-- Head -->
                    <rect x="18" y="5" width="24" height="20" fill="#2F2F2F"/>
                    <rect x="15" y="8" width="30" height="14" fill="#1C1C1C"/>
                    <!-- Face -->
                    <rect x="22" y="12" width="4" height="6" fill="#8B0000"/>
                    <rect x="34" y="12" width="4" height="6" fill="#8B0000"/>
                    <rect x="24" y="14" width="2" height="2" fill="#FF0000"/>
                    <rect x="36" y="14" width="2" height="2" fill="#FF0000"/>
                    <rect x="26" y="18" width="8" height="3" fill="#8B0000"/>
                    <rect x="28" y="19" width="1" height="1" fill="#000"/>
                    <rect x="31" y="19" width="1" height="1" fill="#000"/>
                    <!-- Body -->
                    <rect x="21" y="25" width="18" height="25" fill="#404040"/>
                    <rect x="18" y="28" width="24" height="19" fill="#2F2F2F"/>
                    <!-- Arms -->
                    <rect x="9" y="30" width="12" height="18" fill="#2F2F2F"/>
                    <rect x="39" y="30" width="12" height="18" fill="#2F2F2F"/>
                    <!-- Legs -->
                    <rect x="21" y="50" width="8" height="10" fill="#404040"/>
                    <rect x="31" y="50" width="8" height="10" fill="#404040"/>
                    <!-- Sword -->
                    <rect x="3" y="25" width="4" height="20" fill="#C0C0C0"/>
                    <rect x="1" y="20" width="8" height="8" fill="#8B4513"/>
                </svg>
            `,
            blaze: `
                <svg width="80" height="80" viewBox="0 0 80 80">
                    <!-- Main body -->
                    <rect x="30" y="20" width="20" height="40" fill="#FFAA00"/>
                    <rect x="25" y="25" width="30" height="30" fill="#FF8800"/>
                    <!-- Fire rods rotating around -->
                    <rect x="15" y="15" width="4" height="20" fill="#FF4500" transform="rotate(45 17 25)"/>
                    <rect x="61" y="15" width="4" height="20" fill="#FF4500" transform="rotate(-45 63 25)"/>
                    <rect x="15" y="45" width="4" height="20" fill="#FF4500" transform="rotate(-45 17 55)"/>
                    <rect x="61" y="45" width="4" height="20" fill="#FF4500" transform="rotate(45 63 55)"/>
                    <rect x="5" y="30" width="4" height="20" fill="#FF6600" transform="rotate(90 7 40)"/>
                    <rect x="71" y="30" width="4" height="20" fill="#FF6600" transform="rotate(90 73 40)"/>
                    <!-- Face -->
                    <rect x="32" y="28" width="4" height="4" fill="#8B0000"/>
                    <rect x="44" y="28" width="4" height="4" fill="#8B0000"/>
                    <rect x="36" y="36" width="8" height="4" fill="#000"/>
                    <!-- Inner fire glow -->
                    <rect x="32" y="22" width="16" height="36" fill="#FFFF00" opacity="0.6"/>
                    <rect x="35" y="25" width="10" height="30" fill="#FFFFFF" opacity="0.3"/>
                </svg>
            `,
            ghast: `
                <svg width="100" height="100" viewBox="0 0 100 100">
                    <!-- Main body -->
                    <rect x="10" y="10" width="80" height="60" fill="#F5F5F5"/>
                    <rect x="5" y="15" width="90" height="50" fill="#FFFFFF"/>
                    <!-- Face -->
                    <rect x="25" y="25" width="12" height="12" fill="#000"/>
                    <rect x="63" y="25" width="12" height="12" fill="#000"/>
                    <rect x="27" y="27" width="8" height="8" fill="#8B0000"/>
                    <rect x="65" y="27" width="8" height="8" fill="#8B0000"/>
                    <!-- Mouth -->
                    <rect x="40" y="45" width="20" height="8" fill="#000"/>
                    <rect x="42" y="47" width="4" height="4" fill="#FFFFFF"/>
                    <rect x="50" y="47" width="4" height="4" fill="#FFFFFF"/>
                    <rect x="58" y="47" width="4" height="4" fill="#FFFFFF"/>
                    <!-- Tentacles -->
                    <rect x="15" y="70" width="6" height="25" fill="#F0F0F0"/>
                    <rect x="25" y="70" width="6" height="20" fill="#F0F0F0"/>
                    <rect x="35" y="70" width="6" height="22" fill="#F0F0F0"/>
                    <rect x="45" y="70" width="6" height="18" fill="#F0F0F0"/>
                    <rect x="55" y="70" width="6" height="24" fill="#F0F0F0"/>
                    <rect x="65" y="70" width="6" height="19" fill="#F0F0F0"/>
                    <rect x="75" y="70" width="6" height="21" fill="#F0F0F0"/>
                    <!-- Floating effect -->
                    <rect x="12" y="68" width="76" height="2" fill="#E0E0E0" opacity="0.5"/>
                </svg>
            `,
            wither: `
                <svg width="100" height="80" viewBox="0 0 100 80">
                    <!-- Main head (center) -->
                    <rect x="35" y="5" width="30" height="25" fill="#1C1C1C"/>
                    <rect x="32" y="8" width="36" height="19" fill="#000000"/>
                    <!-- Side heads -->
                    <rect x="10" y="15" width="20" height="18" fill="#1C1C1C"/>
                    <rect x="70" y="15" width="20" height="18" fill="#1C1C1C"/>
                    <!-- Main head face -->
                    <rect x="40" y="12" width="4" height="6" fill="#4169E1"/>
                    <rect x="56" y="12" width="4" height="6" fill="#4169E1"/>
                    <rect x="44" y="18" width="12" height="4" fill="#4169E1"/>
                    <!-- Side heads faces -->
                    <rect x="15" y="20" width="3" height="4" fill="#4169E1"/>
                    <rect x="22" y="20" width="3" height="4" fill="#4169E1"/>
                    <rect x="75" y="20" width="3" height="4" fill="#4169E1"/>
                    <rect x="82" y="20" width="3" height="4" fill="#4169E1"/>
                    <!-- Body -->
                    <rect x="25" y="30" width="50" height="30" fill="#2F2F2F"/>
                    <rect x="20" y="35" width="60" height="20" fill="#1C1C1C"/>
                    <!-- Ribs -->
                    <rect x="30" y="40" width="40" height="2" fill="#696969"/>
                    <rect x="30" y="45" width="40" height="2" fill="#696969"/>
                    <rect x="30" y="50" width="40" height="2" fill="#696969"/>
                    <!-- Spine -->
                    <rect x="48" y="60" width="4" height="20" fill="#696969"/>
                    <!-- Dark aura effect -->
                    <circle cx="50" cy="40" r="45" fill="#000000" opacity="0.1"/>
                </svg>
            `
        };

        // Create sprite element
        function createSprite(type, x, y) {
            const sprite = document.createElement('div');
            sprite.className = `sprite ${type}`;
            sprite.style.left = x + 'px';
            sprite.style.top = y + 'px';
            sprite.innerHTML = sprites[type === 'player' ? 'chicken' : type];
            return sprite;
        }

        // Get canvas dimensions
        function getCanvasDimensions() {
            const canvas = document.getElementById('gameCanvas');
            return {
                width: canvas.offsetWidth,
                height: canvas.offsetHeight
            };
        }

        // Initialize player
        function initPlayer() {
            const canvasSize = getCanvasDimensions();
            game.player = {
                element: createSprite('player', (canvasSize.width - 100) / 2, canvasSize.height - 120),
                x: (canvasSize.width - 100) / 2,
                y: canvasSize.height - 120,
                speed: 6
            };
            game.canvas.appendChild(game.player.element);
        }

        // Create enemy formation positions and spawn queue
        function createEnemies() {
            const canvasSize = getCanvasDimensions();
            
            // Set enemy types based on selected dimension
            let enemyTypes;
            if (game.selectedDimension === 'nether') {
                enemyTypes = ['piglin', 'zombie_piglin', 'wither_skeleton'];
            } else {
                enemyTypes = ['zombie', 'creeper', 'skeleton'];
            }
            
            game.enemiesDefeated = 0;
            game.formationComplete = false;
            game.formationPositions = [];
            game.enemySpawnQueue = [];
            
            // Check if this is a boss level (every 5th level)
            const isBossLevel = game.level % 5 === 0;
            
            if (isBossLevel) {
                // Check if boss already created for this level
                if (game.bossCreated) {
                    return; // Boss already exists, don't create another
                }
                
                // Play boss entrance music and delay boss spawn
                sounds.bossEntrance();
                
                // Set flags to prevent multiple boss creation
                game.bossEntranceInProgress = true;
                game.bossCreated = true;
                
                // Delay actual boss creation until after musical phrase
                setTimeout(() => {
                    // Double-check boss hasn't been created already
                    if (game.enemies.some(enemy => enemy.isBoss)) {
                        game.bossEntranceInProgress = false;
                        return;
                    }
                    createBossLevel(canvasSize);
                }, 2500); // Wait for music + explosion to finish
                
                return; // Exit early for boss levels
            }
            
            // Regular level - create formation
            const formationPattern = getFormationPattern(game.level);
            createFormationPositions(formationPattern, canvasSize);
            
            game.totalEnemiesInLevel = game.formationPositions.length;
            
            // Create spawn queue with level-appropriate enemy distribution
            game.formationPositions.forEach((pos, index) => {
                const enemyType = getEnemyTypeForLevel(game.level, index, game.formationPositions.length);
                game.enemySpawnQueue.push({
                    type: enemyType,
                    formationIndex: index,
                    isBoss: false
                });
            });
            
            // Shuffle spawn queue for more varied entry
            for (let i = game.enemySpawnQueue.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [game.enemySpawnQueue[i], game.enemySpawnQueue[j]] = [game.enemySpawnQueue[j], game.enemySpawnQueue[i]];
            }
        }
        
        function createBossLevel(canvasSize) {
            // Boss level - create and spawn single boss enemy directly
            const bossType = getBossTypeForLevel(game.level);
            const bossX = canvasSize.width / 2 - 50; // Center boss horizontally
            const bossY = canvasSize.height * 0.2;   // Place boss higher up
            
            // Create boss enemy directly
            const boss = {
                element: createSprite('enemy', bossX, bossY),
                x: bossX,
                y: bossY,
                formationX: bossX,
                formationY: bossY,
                formationIndex: 0,
                type: bossType,
                lastShot: 0,
                state: 'formation', // Boss starts in formation immediately
                progress: 0,
                capturedPlayer: null,
                canCapture: false,
                isBoss: true,
                maxHealth: getBossHealth(bossType),
                health: getBossHealth(bossType)
            };
            
            boss.element.innerHTML = sprites[bossType];
            
            // Show boss health bar
            showBossHealth(boss.type, boss.health, boss.maxHealth);
            
            // Add boss to game
            game.enemies.push(boss);
            game.canvas.appendChild(boss.element);
            
            // Set up level completion tracking
            game.formationPositions = [{ x: bossX, y: bossY, occupied: true }];
            game.enemySpawnQueue = []; // Empty queue for boss levels
            game.totalEnemiesInLevel = 1;
            game.formationComplete = true; // Boss is immediately in formation
            
            // Clear the entrance flag
            game.bossEntranceInProgress = false;
        }
        
        function getFormationPattern(level) {
            // Different formation patterns based on level
            const patterns = ['grid', 'diamond', 'circle', 'triangle', 'zigzag', 'double_diamond', 'spiral'];
            return patterns[Math.min(level - 1, patterns.length - 1)];
        }
        
        function createFormationPositions(pattern, canvasSize) {
            const centerX = canvasSize.width / 2;
            const centerY = canvasSize.height * 0.25;
            const spacing = 70;
            
            switch(pattern) {
                case 'grid':
                    createGridFormation(centerX, centerY, spacing);
                    break;
                case 'diamond':
                    createDiamondFormation(centerX, centerY, spacing);
                    break;
                case 'circle':
                    createCircleFormation(centerX, centerY, spacing);
                    break;
                case 'triangle':
                    createTriangleFormation(centerX, centerY, spacing);
                    break;
                case 'zigzag':
                    createZigzagFormation(centerX, centerY, spacing);
                    break;
                case 'double_diamond':
                    createDoubleDiamondFormation(centerX, centerY, spacing);
                    break;
                case 'spiral':
                    createSpiralFormation(centerX, centerY, spacing);
                    break;
            }
        }
        
        function createGridFormation(centerX, centerY, spacing) {
            const rows = Math.min(4 + Math.floor(game.level / 2), 6);
            const cols = Math.min(6 + Math.floor(game.level / 2), 8);
            const startX = centerX - (cols * spacing) / 2;
            
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    game.formationPositions.push({
                        x: startX + col * spacing,
                        y: centerY + row * spacing * 0.8,
                        occupied: false
                    });
                }
            }
        }
        
        function createDiamondFormation(centerX, centerY, spacing) {
            const size = Math.min(3 + Math.floor(game.level / 3), 5);
            
            for (let row = 0; row < size * 2 - 1; row++) {
                const width = row < size ? row + 1 : (size * 2 - 1) - row;
                const startCol = Math.floor((size - width) / 2);
                
                for (let col = 0; col < width; col++) {
                    game.formationPositions.push({
                        x: centerX + (startCol + col - size / 2) * spacing,
                        y: centerY + (row - size / 2) * spacing * 0.8,
                        occupied: false
                    });
                }
            }
        }
        
        function createCircleFormation(centerX, centerY, spacing) {
            const radius = spacing * 2;
            const enemyCount = Math.min(12 + game.level * 2, 24);
            
            for (let i = 0; i < enemyCount; i++) {
                const angle = (i / enemyCount) * Math.PI * 2;
                game.formationPositions.push({
                    x: centerX + Math.cos(angle) * radius,
                    y: centerY + Math.sin(angle) * radius * 0.6,
                    occupied: false
                });
            }
        }
        
        function createTriangleFormation(centerX, centerY, spacing) {
            const rows = Math.min(4 + Math.floor(game.level / 2), 7);
            
            for (let row = 0; row < rows; row++) {
                const width = row + 1;
                for (let col = 0; col < width; col++) {
                    game.formationPositions.push({
                        x: centerX + (col - width / 2) * spacing,
                        y: centerY + row * spacing * 0.8,
                        occupied: false
                    });
                }
            }
        }
        
        function createZigzagFormation(centerX, centerY, spacing) {
            const rows = Math.min(3 + Math.floor(game.level / 2), 5);
            const cols = Math.min(6 + game.level, 10);
            
            for (let row = 0; row < rows; row++) {
                const offset = (row % 2) * spacing * 0.5;
                for (let col = 0; col < cols; col++) {
                    game.formationPositions.push({
                        x: centerX + (col - cols / 2) * spacing + offset,
                        y: centerY + row * spacing * 0.8,
                        occupied: false
                    });
                }
            }
        }
        
        function createDoubleDiamondFormation(centerX, centerY, spacing) {
            // Create two diamond formations
            createDiamondAtPosition(centerX - spacing * 1.5, centerY, spacing * 0.8);
            createDiamondAtPosition(centerX + spacing * 1.5, centerY, spacing * 0.8);
        }
        
        function createDiamondAtPosition(centerX, centerY, spacing) {
            const size = Math.min(2 + Math.floor(game.level / 4), 4);
            
            for (let row = 0; row < size * 2 - 1; row++) {
                const width = row < size ? row + 1 : (size * 2 - 1) - row;
                const startCol = Math.floor((size - width) / 2);
                
                for (let col = 0; col < width; col++) {
                    game.formationPositions.push({
                        x: centerX + (startCol + col - size / 2) * spacing,
                        y: centerY + (row - size / 2) * spacing * 0.8,
                        occupied: false
                    });
                }
            }
        }
        
        function createSpiralFormation(centerX, centerY, spacing) {
            const turns = Math.min(2 + Math.floor(game.level / 3), 4);
            const pointsPerTurn = 8;
            const totalPoints = turns * pointsPerTurn;
            
            for (let i = 0; i < totalPoints; i++) {
                const progress = i / totalPoints;
                const angle = progress * turns * Math.PI * 2;
                const radius = progress * spacing * 2;
                
                game.formationPositions.push({
                    x: centerX + Math.cos(angle) * radius,
                    y: centerY + Math.sin(angle) * radius * 0.6,
                    occupied: false
                });
            }
        }
        
        function getEnemyTypeForLevel(level, index, totalEnemies) {
            let enemyTypes;
            if (game.selectedDimension === 'nether') {
                enemyTypes = ['piglin', 'zombie_piglin', 'wither_skeleton'];
            } else {
                enemyTypes = ['zombie', 'creeper', 'skeleton'];
            }
            return enemyTypes[index % enemyTypes.length];
        }

        function getBossTypeForLevel(level) {
            const bossIndex = Math.floor((level / 5) - 1) % 3;
            
            if (game.selectedDimension === 'nether') {
                // Nether bosses: Blaze, Ghast, Wither
                const netherBossTypes = ['blaze', 'ghast', 'wither'];
                return netherBossTypes[bossIndex];
            } else {
                // Overworld bosses: Witch, Evoker, Ravager, Warden (cycling through 4)
                const overworldBossIndex = Math.floor((level / 5) - 1) % 4;
                const overworldBossTypes = ['witch', 'evoker', 'ravager', 'warden'];
                return overworldBossTypes[overworldBossIndex];
            }
        }

        function getBossHealth(bossType) {
            const healthMap = {
                // Overworld bosses
                'witch': 20,
                'evoker': 30,
                'ravager': 40,
                'warden': 50,
                // Nether bosses
                'blaze': 20,
                'ghast': 30,
                'wither': 50
            };
            return healthMap[bossType] || 1;
        }

        // Move player
        function movePlayer() {
            if (!game.player || game.capturedPlayer) return;
            
            const canvasSize = getCanvasDimensions();
            const minY = canvasSize.height * 0.6; // Player can only move in bottom 40% of screen
            
            if (game.keys['ArrowLeft'] && game.player.x > 0) {
                game.player.x -= game.player.speed;
            }
            if (game.keys['ArrowRight'] && game.player.x < canvasSize.width - 100) {
                game.player.x += game.player.speed;
            }
            if (game.keys['ArrowUp'] && game.player.y > minY) {
                game.player.y -= game.player.speed;
            }
            if (game.keys['ArrowDown'] && game.player.y < canvasSize.height - 80) {
                game.player.y += game.player.speed;
            }
            
            game.player.element.style.left = game.player.x + 'px';
            game.player.element.style.top = game.player.y + 'px';
            
            // Move dual ship if it exists
            if (game.player.dualShip) {
                game.player.dualShip.x = game.player.x - 60;
                game.player.dualShip.y = game.player.y;
                game.player.dualShip.element.style.left = game.player.dualShip.x + 'px';
                game.player.dualShip.element.style.top = game.player.dualShip.y + 'px';
            }
        }

        // Power-up functions
        function activatePowerUp(type) {
            const powerUp = powerUps.types[type];
            
            switch(powerUp.effect) {
                case 'invincibility':
                    powerUps.active.invincibility = Date.now() + powerUp.duration;
                    break;
                case 'rapidFire':
                    powerUps.active.rapidFire = Date.now() + powerUp.duration;
                    break;
                case 'extraLife':
                    game.lives++;
                    document.getElementById('lives').textContent = game.lives;
                    break;
                case 'slowEnemies':
                    powerUps.active.slowEnemies = Date.now() + powerUp.duration;
                    break;
                case 'explosion':
                    game.nextExplosiveShot = true;
                    break;
                case 'spreadingFire':
                    powerUps.active.spreadingFire = Date.now() + powerUp.duration;
                    break;
                case 'lavaChicken':
                    powerUps.active.lavaChicken = Date.now() + powerUp.duration;
                    break;
                case 'shield':
                    powerUps.active.shield = Date.now() + powerUp.duration;
                    break;
                case 'freezeEnemies':
                    powerUps.active.freezeEnemies = Date.now() + powerUp.duration;
                    break;
            }
            
            updatePowerUpDisplay();
        }
        
        function updatePowerUpDisplay() {
            const now = Date.now();
            const activeEffects = [];
            
            Object.keys(powerUps.active).forEach(effect => {
                if (powerUps.active[effect] > now) {
                    activeEffects.push(effect);
                } else {
                    delete powerUps.active[effect];
                }
            });
            
            if (game.nextExplosiveShot) activeEffects.push('TNT Ready');
            if (powerUps.active.spreadingFire && powerUps.active.spreadingFire > now) activeEffects.push('Spreading Fire');
            
            const indicator = document.getElementById('powerupIndicator');
            const display = document.getElementById('activePowerup');
            
            if (activeEffects.length > 0) {
                indicator.style.display = 'block';
                display.textContent = activeEffects.join(', ');
            } else {
                indicator.style.display = 'none';
            }
        }
        
        function spawnPowerUp() {
            const now = Date.now();
            if (now - game.lastPowerUpSpawn < 8000) return; // Minimum 8 seconds between spawns
            
            if (Math.random() < 0.25) { // 25% chance
                const canvasSize = getCanvasDimensions();
                const types = Object.keys(powerUps.types);
                const randomType = types[Math.floor(Math.random() * types.length)];
                
                const x = Math.random() * (canvasSize.width - 40);
                const powerUp = {
                    element: createSprite('powerup', x, -40),
                    x: x,
                    y: -40,
                    type: randomType,
                    speed: 2
                };
                
                powerUp.element.innerHTML = sprites[randomType];
                powerUps.items.push(powerUp);
                game.canvas.appendChild(powerUp.element);
                game.lastPowerUpSpawn = now;
                
                console.log('PowerUp spawned:', randomType, 'at', x, -40);
            }
        }
        
        function triggerVerticalBlast() {
            if (!game.player) return;
            
            const canvasSize = getCanvasDimensions();
            const blastX = game.player.x + 50; // Center of player
            
            // Create vertical blast effect
            const blastEffect = {
                element: createSprite('vertical-blast', blastX - 20, 0),
                x: blastX - 20,
                y: 0,
                width: 40,
                height: canvasSize.height,
                life: 60, // frames to show effect
                maxLife: 60
            };
            
            // Create custom SVG for vertical blast effect
            blastEffect.element.innerHTML = `
                <svg width="40" height="${canvasSize.height}" viewBox="0 0 40 ${canvasSize.height}">
                    <rect x="0" y="0" width="40" height="${canvasSize.height}" fill="#FF4500" opacity="0.8"/>
                    <rect x="5" y="0" width="30" height="${canvasSize.height}" fill="#FF6347" opacity="0.9"/>
                    <rect x="10" y="0" width="20" height="${canvasSize.height}" fill="#FFD700" opacity="0.7"/>
                    <rect x="15" y="0" width="10" height="${canvasSize.height}" fill="#FFFFFF" opacity="0.5"/>
                </svg>
            `;
            
            blastEffect.element.style.pointerEvents = 'none';
            blastEffect.element.style.zIndex = '150';
            game.canvas.appendChild(blastEffect.element);
            
            // Destroy all enemies in the vertical line
            for (let eIndex = game.enemies.length - 1; eIndex >= 0; eIndex--) {
                const enemy = game.enemies[eIndex];
                if (!enemy || !enemy.element) continue;
                
                const enemyCenterX = enemy.x + 30; // Enemy width is 60
                
                // Check if enemy is within the vertical blast line
                if (enemyCenterX >= blastX - 20 && enemyCenterX <= blastX + 20) {
                    // Check if this enemy has captured player
                    if (enemy.capturedPlayer) {
                        rescuePlayer(enemy);
                    }
                    
                    // Remove enemy
                    if (enemy.element && enemy.element.parentNode) {
                        game.canvas.removeChild(enemy.element);
                    }
                    
                    // Award points
                    let points = 150 + (game.level - 1) * 15; // Bonus points for vertical blast
                    if (enemy.type === 'creeper') points = 200 + (game.level - 1) * 20;
                    
                    game.score += points;
                    game.enemiesDefeated++;
                    game.enemies.splice(eIndex, 1);
                    
                    sounds.enemyHit();
                }
            }
            
            // Update score display
            document.getElementById('score').textContent = game.score;
            updateHighScore();
            
            // Remove blast effect after duration
            setTimeout(() => {
                if (blastEffect.element && blastEffect.element.parentNode) {
                    game.canvas.removeChild(blastEffect.element);
                }
            }, 500); // Show for 500ms
        }
        
        function createFireSpreadEffect(startX, startY) {
            // Create multiple fire spread sprites that move outward
            const directions = [
                {x: -1, y: -1}, {x: 0, y: -1}, {x: 1, y: -1},
                {x: -1, y: 0},                 {x: 1, y: 0},
                {x: -1, y: 1},  {x: 0, y: 1},  {x: 1, y: 1}
            ];
            
            directions.forEach((dir, index) => {
                setTimeout(() => {
                    const fireSpread = {
                        element: createSprite('fire-spread', startX, startY),
                        x: startX,
                        y: startY,
                        vx: dir.x * 3, // velocity
                        vy: dir.y * 3,
                        life: 30, // frames to live
                        maxLife: 30
                    };
                    
                    fireSpread.element.innerHTML = sprites.fireSpread;
                    game.fireSpreadEffects.push(fireSpread);
                    game.canvas.appendChild(fireSpread.element);
                }, index * 50); // Stagger the creation
            });
        }
        
        function moveFireSpreadEffects() {
            for (let index = game.fireSpreadEffects.length - 1; index >= 0; index--) {
                const fire = game.fireSpreadEffects[index];
                if (!fire || !fire.element) continue;
                
                // Move the fire spread
                fire.x += fire.vx;
                fire.y += fire.vy;
                fire.life--;
                
                // Fade out over time
                const opacity = fire.life / fire.maxLife;
                fire.element.style.opacity = opacity;
                fire.element.style.left = fire.x + 'px';
                fire.element.style.top = fire.y + 'px';
                
                // Check collision with enemies
                for (let eIndex = game.enemies.length - 1; eIndex >= 0; eIndex--) {
                    const enemy = game.enemies[eIndex];
                    if (!enemy || !enemy.element) continue;
                    
                    const distance = Math.sqrt(
                        Math.pow(fire.x - enemy.x, 2) + 
                        Math.pow(fire.y - enemy.y, 2)
                    );
                    
                    if (distance < 40) {
                        // Destroy enemy
                        if (enemy.element && enemy.element.parentNode) {
                            game.canvas.removeChild(enemy.element);
                        }
                        
                        let points = 75 + (game.level - 1) * 7; // Spread fire points
                        if (enemy.type === 'creeper') points = 112 + (game.level - 1) * 11;
                        
                        game.score += points;
                        game.enemiesDefeated++;
                        game.enemies.splice(eIndex, 1);
                        document.getElementById('score').textContent = game.score;
                        updateHighScore();
                        
                        // Create secondary fire spread from this enemy
                        if (Math.random() < 0.3) { // 30% chance to spread further
                            createFireSpreadEffect(enemy.x + 20, enemy.y + 20);
                        }
                        
                        sounds.enemyHit();
                        break;
                    }
                }
                
                // Remove fire spread when life expires
                if (fire.life <= 0) {
                    if (fire.element && fire.element.parentNode) {
                        game.canvas.removeChild(fire.element);
                    }
                    game.fireSpreadEffects.splice(index, 1);
                }
            }
        }
        
        function updateShieldEffect() {
            const now = Date.now();
            
            // Remove existing shield effect if shield is not active
            const existingShield = document.getElementById('playerShield');
            if (!powerUps.active.shield || powerUps.active.shield <= now) {
                if (existingShield) {
                    existingShield.remove();
                }
                return;
            }
            
            // Create shield effect if it doesn't exist and shield is active
            if (!existingShield && game.player) {
                const shieldEffect = document.createElement('div');
                shieldEffect.id = 'playerShield';
                shieldEffect.className = 'sprite';
                shieldEffect.style.width = '160px';
                shieldEffect.style.height = '160px';
                shieldEffect.style.pointerEvents = 'none';
                shieldEffect.style.zIndex = '50';
                
                // Create animated shield SVG
                shieldEffect.innerHTML = `
                    <svg width="160" height="160" viewBox="0 0 160 160">
                        <defs>
                            <radialGradient id="shieldGradient" cx="50%" cy="50%" r="50%">
                                <stop offset="0%" style="stop-color:#87CEEB;stop-opacity:0.3" />
                                <stop offset="70%" style="stop-color:#4A90E2;stop-opacity:0.6" />
                                <stop offset="100%" style="stop-color:#2C5A80;stop-opacity:0.8" />
                            </radialGradient>
                        </defs>
                        <circle cx="80" cy="80" r="75" fill="url(#shieldGradient)" stroke="#87CEEB" stroke-width="2" opacity="0.7">
                            <animate attributeName="opacity" values="0.4;0.8;0.4" dur="2s" repeatCount="indefinite"/>
                        </circle>
                        <circle cx="80" cy="80" r="60" fill="none" stroke="#FFFFFF" stroke-width="1" opacity="0.5">
                            <animate attributeName="stroke-opacity" values="0.2;0.6;0.2" dur="1.5s" repeatCount="indefinite"/>
                        </circle>
                    </svg>
                `;
                
                game.canvas.appendChild(shieldEffect);
            }
            
            // Update shield position to follow player
            if (existingShield && game.player) {
                const shieldX = game.player.x - 30; // Center the shield around player
                const shieldY = game.player.y - 40;
                existingShield.style.left = shieldX + 'px';
                existingShield.style.top = shieldY + 'px';
            }
        }
        
        function updateFreezeEffect() {
            const now = Date.now();
            const isFrozen = powerUps.active.freezeEnemies && powerUps.active.freezeEnemies > now;
            
            game.enemies.forEach((enemy, index) => {
                if (!enemy || !enemy.element) return;
                
                const freezeId = `freeze-${index}`;
                const existingFreeze = document.getElementById(freezeId);
                
                if (isFrozen && !existingFreeze) {
                    // Add freeze effect
                    const freezeEffect = document.createElement('div');
                    freezeEffect.id = freezeId;
                    freezeEffect.className = 'sprite';
                    freezeEffect.style.width = '60px';
                    freezeEffect.style.height = '60px';
                    freezeEffect.style.pointerEvents = 'none';
                    freezeEffect.style.zIndex = '60';
                    freezeEffect.style.left = enemy.x + 'px';
                    freezeEffect.style.top = enemy.y + 'px';
                    
                    // Create ice overlay effect
                    freezeEffect.innerHTML = `
                        <svg width="60" height="60" viewBox="0 0 60 60">
                            <!-- Ice overlay -->
                            <rect x="0" y="0" width="60" height="60" fill="#B0E0E6" opacity="0.5"/>
                            <!-- Ice crystals -->
                            <polygon points="30,8 32,12 28,12" fill="#FFFFFF" opacity="0.8"/>
                            <polygon points="30,52 32,48 28,48" fill="#FFFFFF" opacity="0.8"/>
                            <polygon points="8,30 12,32 12,28" fill="#FFFFFF" opacity="0.8"/>
                            <polygon points="52,30 48,32 48,28" fill="#FFFFFF" opacity="0.8"/>
                            <!-- Ice sparkles -->
                            <circle cx="20" cy="20" r="1" fill="#FFFFFF" opacity="1">
                                <animate attributeName="opacity" values="0;1;0" dur="1s" repeatCount="indefinite"/>
                            </circle>
                            <circle cx="40" cy="20" r="1" fill="#FFFFFF" opacity="1">
                                <animate attributeName="opacity" values="1;0;1" dur="1s" repeatCount="indefinite"/>
                            </circle>
                            <circle cx="20" cy="40" r="1" fill="#FFFFFF" opacity="1">
                                <animate attributeName="opacity" values="0;1;0" dur="1.5s" repeatCount="indefinite"/>
                            </circle>
                            <circle cx="40" cy="40" r="1" fill="#FFFFFF" opacity="1">
                                <animate attributeName="opacity" values="1;0;1" dur="1.5s" repeatCount="indefinite"/>
                            </circle>
                        </svg>
                    `;
                    
                    game.canvas.appendChild(freezeEffect);
                } else if (!isFrozen && existingFreeze) {
                    // Remove freeze effect
                    existingFreeze.remove();
                } else if (isFrozen && existingFreeze) {
                    // Update freeze effect position
                    existingFreeze.style.left = enemy.x + 'px';
                    existingFreeze.style.top = enemy.y + 'px';
                }
            });
            
            // Clean up freeze effects for destroyed enemies
            if (!isFrozen) {
                const allFreezeEffects = document.querySelectorAll('[id^="freeze-"]');
                allFreezeEffects.forEach(effect => effect.remove());
            }
        }
        
        function movePowerUps() {
            for (let index = powerUps.items.length - 1; index >= 0; index--) {
                const powerUp = powerUps.items[index];
                if (!powerUp || !powerUp.element) continue;
                
                powerUp.y += powerUp.speed;
                powerUp.element.style.top = powerUp.y + 'px';
                
                const canvasSize = getCanvasDimensions();
                if (powerUp.y > canvasSize.height) {
                    if (powerUp.element && powerUp.element.parentNode) {
                        game.canvas.removeChild(powerUp.element);
                    }
                    powerUps.items.splice(index, 1);
                }
            }
        }
        

        // Shoot projectile
        function shoot() {
            if (!game.player || game.capturedPlayer) return;
            
            const now = Date.now();
            const fireRate = powerUps.active.rapidFire && powerUps.active.rapidFire > now ? 66 : 200; // 3x faster with rapid fire
            
            if (now - game.lastShot > fireRate) {
                // Main ship projectile
                const projectile = {
                    element: createSprite('projectile', game.player.x + 42, game.player.y),
                    x: game.player.x + 42,
                    y: game.player.y,
                    speed: 10,
                    explosive: game.nextExplosiveShot
                };
                
                projectile.element.innerHTML = sprites.egg;
                game.projectiles.push(projectile);
                game.canvas.appendChild(projectile.element);
                
                // Dual ship projectile if available
                if (game.player.dualShip) {
                    const dualProjectile = {
                        element: createSprite('projectile', game.player.dualShip.x + 42, game.player.dualShip.y),
                        x: game.player.dualShip.x + 42,
                        y: game.player.dualShip.y,
                        speed: 10,
                        explosive: false
                    };
                    
                    dualProjectile.element.innerHTML = sprites.egg;
                    game.projectiles.push(dualProjectile);
                    game.canvas.appendChild(dualProjectile.element);
                }
                
                if (game.nextExplosiveShot) {
                    game.nextExplosiveShot = false;
                    updatePowerUpDisplay();
                }
                
                // Check for lava chicken effect
                if (powerUps.active.lavaChicken && powerUps.active.lavaChicken > now) {
                    triggerVerticalBlast();
                    sounds.chicken();
                } else {
                    sounds.shoot();
                }
                
                game.lastShot = now;
            }
        }

        // Enemy shooting
        function enemyShoot() {
            const now = Date.now();
            
            // Don't shoot if enemies are frozen
            if (powerUps.active.freezeEnemies && powerUps.active.freezeEnemies > now) {
                return;
            }
            
            const levelMultiplier = 1 + (game.level * 0.2); // More aggressive shooting at higher levels
            const baseChance = 0.001 * game.snowballFrequency * levelMultiplier;
            const shootCooldown = Math.max(1000, 2000 - (game.level * 100)); // Faster shooting at higher levels
            
            game.enemies.forEach(enemy => {
                let shouldShoot = false;
                let customCooldown = shootCooldown;
                
                if (enemy.isBoss) {
                    // Boss-specific shooting patterns (4x frequency)
                    if (enemy.type === 'witch') {
                        customCooldown = 625; // Witch shoots more frequently and causes 2 damage
                        shouldShoot = now - enemy.lastShot > customCooldown && Math.random() < baseChance * 6;
                    } else if (enemy.type === 'evoker') {
                        customCooldown = 200; // Evoker rapid fire even faster
                        shouldShoot = now - enemy.lastShot > customCooldown && Math.random() < baseChance * 8;
                    } else if (enemy.type === 'ravager') {
                        customCooldown = 450; // Ravager shoots big snowballs more often
                        shouldShoot = now - enemy.lastShot > customCooldown && Math.random() < baseChance * 4.8;
                    } else if (enemy.type === 'warden') {
                        customCooldown = 750; // Warden shoots 5 snowballs more frequently
                        shouldShoot = now - enemy.lastShot > customCooldown && Math.random() < baseChance * 3.2;
                    } else if (enemy.type === 'blaze') {
                        customCooldown = 800; // Blaze spreading fire attack
                        shouldShoot = now - enemy.lastShot > customCooldown && Math.random() < baseChance * 3.5;
                    } else if (enemy.type === 'ghast') {
                        customCooldown = 1000; // Ghast large fireballs and ender pearls
                        shouldShoot = now - enemy.lastShot > customCooldown && Math.random() < baseChance * 2.8;
                    } else if (enemy.type === 'wither') {
                        customCooldown = 50; // Very fast cooldown for Wither's burst pattern
                        shouldShoot = now - enemy.lastShot > customCooldown && Math.random() < baseChance * 15;
                    }
                } else {
                    shouldShoot = now - enemy.lastShot > shootCooldown && Math.random() < baseChance;
                }
                
                if (shouldShoot) {
                    if (enemy.isBoss) {
                        // Boss-specific attacks
                        if (enemy.type === 'witch') {
                            createWitchSnowball(enemy, now);
                        } else if (enemy.type === 'evoker') {
                            createEvokerRapidFire(enemy, now);
                        } else if (enemy.type === 'ravager') {
                            createRavagerBigSnowball(enemy, now);
                        } else if (enemy.type === 'warden') {
                            createWardenMultiShot(enemy, now);
                        } else if (enemy.type === 'blaze') {
                            createBlazeSpreadingFire(enemy, now);
                        } else if (enemy.type === 'ghast') {
                            // Ghast alternates between large fireballs and ender pearls
                            if (Math.random() < 0.7) {
                                createGhastLargeFireball(enemy, now);
                            } else {
                                createGhastEnderPearl(enemy, now);
                            }
                        } else if (enemy.type === 'wither') {
                            createWitherExplosiveFireball(enemy, now);
                        }
                    } else {
                        // Regular enemy attacks
                        if (game.selectedDimension === 'nether' && (enemy.type === 'piglin' || enemy.type === 'zombie_piglin' || enemy.type === 'wither_skeleton')) {
                            // Nether enemies shoot fireballs
                            createFireballProjectile(enemy, now);
                        } else if (game.level >= 3 && enemy.type === 'creeper' && Math.random() < 0.4) {
                            // Creepers shoot faster projectiles at medium levels
                            createFastProjectile(enemy, now);
                        } else {
                            // Standard projectile
                            createStandardProjectile(enemy, now);
                        }
                    }
                    enemy.lastShot = now;
                }
            });
        }
        
        function createStandardProjectile(enemy, now) {
            const projectile = {
                element: createSprite('enemy-projectile', enemy.x + 20, enemy.y + 60),
                x: enemy.x + 20,
                y: enemy.y + 60,
                speed: 4 + (game.level * 0.2)
            };
            projectile.element.innerHTML = sprites.enderPearl;
            game.enemyProjectiles.push(projectile);
            game.canvas.appendChild(projectile.element);
        }

        function createFireballProjectile(enemy, now) {
            const projectile = {
                element: createSprite('enemy-projectile', enemy.x + 20, enemy.y + 60),
                x: enemy.x + 20,
                y: enemy.y + 60,
                speed: 3.5 + (game.level * 0.15)
            };
            projectile.element.innerHTML = sprites.fireball;
            game.enemyProjectiles.push(projectile);
            game.canvas.appendChild(projectile.element);
        }
        
        function createFastProjectile(enemy, now) {
            const projectile = {
                element: createSprite('enemy-projectile', enemy.x + 20, enemy.y + 60),
                x: enemy.x + 20,
                y: enemy.y + 60,
                speed: 6 + (game.level * 0.3)
            };
            projectile.element.innerHTML = sprites.enderPearl;
            game.enemyProjectiles.push(projectile);
            game.canvas.appendChild(projectile.element);
        }
        
        function createMultipleProjectiles(enemy, now) {
            // Create 3 projectiles in a spread pattern
            for (let i = -1; i <= 1; i++) {
                const projectile = {
                    element: createSprite('enemy-projectile', enemy.x + 20 + (i * 15), enemy.y + 60),
                    x: enemy.x + 20 + (i * 15),
                    y: enemy.y + 60,
                    speed: 5 + (game.level * 0.2),
                    vx: i * 1.5 // Slight horizontal velocity for spread
                };
                projectile.element.innerHTML = sprites.enderPearl;
                game.enemyProjectiles.push(projectile);
                game.canvas.appendChild(projectile.element);
            }
        }

        function createWitchSnowball(enemy, now) {
            const projectile = {
                element: createSprite('enemy-projectile', enemy.x + 30, enemy.y + 80),
                x: enemy.x + 30,
                y: enemy.y + 80,
                speed: 3 + (game.level * 0.2),
                damage: 2 // Witch snowballs cause 2 damage
            };
            projectile.element.innerHTML = sprites.enderPearl;
            projectile.element.style.filter = 'hue-rotate(120deg) brightness(1.2)'; // Green tint for witch
            game.enemyProjectiles.push(projectile);
            game.canvas.appendChild(projectile.element);
        }

        function createEvokerRapidFire(enemy, now) {
            const projectile = {
                element: createSprite('enemy-projectile', enemy.x + 30, enemy.y + 80),
                x: enemy.x + 30,
                y: enemy.y + 80,
                speed: 6 + (game.level * 0.3)
            };
            projectile.element.innerHTML = sprites.enderPearl;
            projectile.element.style.filter = 'hue-rotate(270deg) brightness(1.3)'; // Purple tint for evoker
            game.enemyProjectiles.push(projectile);
            game.canvas.appendChild(projectile.element);
        }

        function createRavagerBigSnowball(enemy, now) {
            const projectile = {
                element: createSprite('enemy-projectile', enemy.x + 40, enemy.y + 85),
                x: enemy.x + 40,
                y: enemy.y + 85,
                speed: 2.5 + (game.level * 0.15)
            };
            projectile.element.innerHTML = sprites.enderPearl;
            projectile.element.style.transform = 'scale(1.8)'; // Extra big snowball
            projectile.element.style.filter = 'brightness(0.8)'; // Darker for ravager
            game.enemyProjectiles.push(projectile);
            game.canvas.appendChild(projectile.element);
        }

        function createWardenMultiShot(enemy, now) {
            // Create 5 projectiles in a spread pattern
            for (let i = -2; i <= 2; i++) {
                const projectile = {
                    element: createSprite('enemy-projectile', enemy.x + 30 + (i * 10), enemy.y + 85),
                    x: enemy.x + 30 + (i * 10),
                    y: enemy.y + 85,
                    speed: 4 + (game.level * 0.2),
                    vx: i * 1.2 // Horizontal spread
                };
                projectile.element.innerHTML = sprites.enderPearl;
                projectile.element.style.filter = 'hue-rotate(180deg) brightness(1.5)'; // Cyan tint for warden
                game.enemyProjectiles.push(projectile);
                game.canvas.appendChild(projectile.element);
            }
        }

        // Nether boss attacks
        function createBlazeSpreadingFire(enemy, now) {
            // Create 5 fireballs in a spreading pattern
            for (let i = -2; i <= 2; i++) {
                const projectile = {
                    element: createSprite('enemy-projectile', enemy.x + 40 + (i * 20), enemy.y + 80),
                    x: enemy.x + 40 + (i * 20),
                    y: enemy.y + 80,
                    speed: 2.5 + (game.level * 0.1),
                    damage: 2
                };
                projectile.element.innerHTML = sprites.fireball;
                projectile.element.style.transform = `scale(${0.8 + Math.abs(i) * 0.1})`;
                game.enemyProjectiles.push(projectile);
                game.canvas.appendChild(projectile.element);
            }
        }

        function createGhastLargeFireball(enemy, now) {
            const projectile = {
                element: createSprite('enemy-projectile', enemy.x + 50, enemy.y + 100),
                x: enemy.x + 50,
                y: enemy.y + 100,
                speed: 2 + (game.level * 0.1),
                damage: 3
            };
            projectile.element.innerHTML = sprites.fireball;
            projectile.element.style.transform = 'scale(2.0)'; // Extra large fireball
            projectile.element.style.filter = 'brightness(1.3)';
            game.enemyProjectiles.push(projectile);
            game.canvas.appendChild(projectile.element);
        }

        function createGhastEnderPearl(enemy, now) {
            const projectile = {
                element: createSprite('enemy-projectile', enemy.x + 50, enemy.y + 100),
                x: enemy.x + 50,
                y: enemy.y + 100,
                speed: 4 + (game.level * 0.2),
                damage: 1
            };
            projectile.element.innerHTML = sprites.enderPearl; 
            projectile.element.style.transform = 'scale(1.2)'; 
            game.enemyProjectiles.push(projectile);
            game.canvas.appendChild(projectile.element);
        }

        function createWitherExplosiveFireball(enemy, now) {
            // Initialize Wither's attack pattern state if it doesn't exist
            if (!enemy.witherAttackState) {
                enemy.witherAttackState = {
                    burstCount: 0,
                    burstPhase: 'shooting', // 'shooting' or 'waiting'
                    lastBurstShot: 0,
                    waitStartTime: 0
                };
            }

            const state = enemy.witherAttackState;
            
            // If in waiting phase, check if wait time is over
            if (state.burstPhase === 'waiting') {
                if (now - state.waitStartTime >= 1000) { // 1 second wait
                    state.burstPhase = 'shooting';
                    state.burstCount = 0;
                }
                return; // Don't shoot during wait phase
            }
            
            // If in shooting phase, fire rapid shots
            if (state.burstPhase === 'shooting') {
                // Super fast shooting - allow shots every 100ms during burst
                if (now - state.lastBurstShot < 100) {
                    return;
                }
                
                // Create big explosive fireball
                const projectile = {
                    element: createSprite('enemy-projectile', enemy.x + 50, enemy.y + 80),
                    x: enemy.x + 50,
                    y: enemy.y + 80,
                    speed: 4 + (game.level * 0.2),
                    damage: 4,
                    explosive: true
                };
                projectile.element.innerHTML = sprites.fireball;
                projectile.element.style.transform = 'scale(2.0)'; // Bigger fireballs
                projectile.element.style.filter = 'hue-rotate(240deg) brightness(1.4)'; // Darker purple tint
                game.enemyProjectiles.push(projectile);
                game.canvas.appendChild(projectile.element);
                
                state.lastBurstShot = now;
                state.burstCount++;
                
                // After 3 shots, switch to waiting phase
                if (state.burstCount >= 3) {
                    state.burstPhase = 'waiting';
                    state.waitStartTime = now;
                }
            }
        }

        // Spawn enemies flying in from sides
        function spawnEnemies() {
            const now = Date.now();
            const spawnRate = Math.max(200, 500 - (game.level * 30)); // Faster spawning at higher levels
            
            // Don't spawn enemies during boss entrance
            if (game.bossEntranceInProgress) return;
            
            if (game.enemySpawnQueue.length === 0 || now - game.lastEnemySpawn < spawnRate) return;
            
            const canvasSize = getCanvasDimensions();
            const spawnData = game.enemySpawnQueue.shift();
            const formationPos = game.formationPositions[spawnData.formationIndex];
            
            // Choose random side to spawn from
            const fromLeft = Math.random() < 0.5;
            const startX = fromLeft ? -60 : canvasSize.width + 60;
            const startY = Math.random() * (canvasSize.height * 0.3) + 50;
            
            const enemy = {
                element: createSprite('enemy', startX, startY),
                x: startX,
                y: startY,
                formationX: formationPos.x,
                formationY: formationPos.y,
                formationIndex: spawnData.formationIndex,
                type: spawnData.type,
                lastShot: 0,
                state: 'entering',
                progress: 0,
                capturedPlayer: null,
                canCapture: false,
                isBoss: spawnData.isBoss || false,
                maxHealth: spawnData.isBoss ? getBossHealth(spawnData.type) : 1,
                health: spawnData.isBoss ? getBossHealth(spawnData.type) : 1
            };
            
            enemy.element.innerHTML = sprites[spawnData.type];
            
            // Show boss health bar for bosses
            if (enemy.isBoss) {
                showBossHealth(enemy.type, enemy.health, enemy.maxHealth);
            }
            
            game.enemies.push(enemy);
            game.canvas.appendChild(enemy.element);
            game.lastEnemySpawn = now;
            
            // Mark formation position as occupied
            formationPos.occupied = true;
            
            // Check if formation is complete
            if (game.enemySpawnQueue.length === 0) {
                game.formationComplete = true;
            }
        }
        
        // Move enemies with new Galaga-style patterns
        function moveEnemies() {
            const now = Date.now();
            
            // Check for freeze effect first, then slow effect
            let speedMultiplier = 1;
            if (powerUps.active.freezeEnemies && powerUps.active.freezeEnemies > now) {
                speedMultiplier = 0; // Completely freeze enemies
            } else if (powerUps.active.slowEnemies && powerUps.active.slowEnemies > now) {
                speedMultiplier = 0.3; // Slow enemies
            }
            
            // Spawn new enemies if needed
            spawnEnemies();
            
            // Handle each enemy based on state
            game.enemies.forEach(enemy => {
                if (enemy.state === 'entering') {
                    moveToFormation(enemy, speedMultiplier);
                } else if (enemy.state === 'formation') {
                    // Enemies in formation stay put until diving (bosses never dive)
                    if (!enemy.isBoss) {
                        const diveChance = Math.min(0.001 + (game.level * 0.0003), 0.005); // Higher dive frequency at higher levels
                        if (game.formationComplete && Math.random() < diveChance) {
                            startDiveAttack(enemy);
                        }
                    } else {
                        // Bosses move randomly across the screen
                        moveBossRandomly(enemy, speedMultiplier, now);
                    }
                } else if (enemy.state === 'diving') {
                    performDiveAttack(enemy, speedMultiplier);
                } else if (enemy.state === 'flyingUp') {
                    flyBackUp(enemy, speedMultiplier);
                } else if (enemy.state === 'returning') {
                    returnToFormation(enemy, speedMultiplier);
                } else if (enemy.state === 'capturing') {
                    performCaptureAttack(enemy, speedMultiplier);
                }
                
                // Update captured player position
                if (enemy.capturedPlayer) {
                    enemy.capturedPlayer.x = enemy.x;
                    enemy.capturedPlayer.y = enemy.y - 50;
                    enemy.capturedPlayer.element.style.left = enemy.capturedPlayer.x + 'px';
                    enemy.capturedPlayer.element.style.top = enemy.capturedPlayer.y + 'px';
                }
            });
        }
        
        function moveToFormation(enemy, speedMultiplier) {
            const baseSpeed = 3 + (game.level * 0.3); // Faster movement at higher levels
            const speed = baseSpeed * speedMultiplier;
            const dx = enemy.formationX - enemy.x;
            const dy = enemy.formationY - enemy.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 5) {
                enemy.x += (dx / distance) * speed;
                enemy.y += (dy / distance) * speed;
                enemy.element.style.left = enemy.x + 'px';
                enemy.element.style.top = enemy.y + 'px';
            } else {
                // Reached formation
                enemy.state = 'formation';
                enemy.x = enemy.formationX;
                enemy.y = enemy.formationY;
                enemy.element.style.left = enemy.x + 'px';
                enemy.element.style.top = enemy.y + 'px';
            }
        }
        
        function startDiveAttack(specificEnemy) {
            let enemy;
            if (specificEnemy) {
                enemy = specificEnemy;
            } else {
                const formationEnemies = game.enemies.filter(e => e.state === 'formation');
                if (formationEnemies.length === 0) return;
                enemy = formationEnemies[Math.floor(Math.random() * formationEnemies.length)];
            }
            
            enemy.state = 'diving';
            enemy.diveProgress = 0;
            
            // Set dive target near player
            const canvasSize = getCanvasDimensions();
            enemy.diveTarget = {
                x: game.player.x + Math.random() * 200 - 100,
                y: canvasSize.height - 100
            };
        }
        
        function performDiveAttack(enemy, speedMultiplier) {
            const baseSpeed = 4 + (game.level * 0.4); // Faster diving at higher levels
            const speed = baseSpeed * speedMultiplier;
            const canvasSize = getCanvasDimensions();
            
            if (enemy.diveTarget) {
                // Diving down toward target
                const dx = enemy.diveTarget.x - enemy.x;
                const dy = enemy.diveTarget.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 10) {
                    // Move towards target
                    enemy.x += (dx / distance) * speed;
                    enemy.y += (dy / distance) * speed;
                    enemy.element.style.left = enemy.x + 'px';
                    enemy.element.style.top = enemy.y + 'px';
                } else {
                    // Reached bottom, start flying back up
                    enemy.diveTarget = null;
                    enemy.state = 'flyingUp';
                }
            }
        }
        
        function flyBackUp(enemy, speedMultiplier) {
            const baseSpeed = 4 + (game.level * 0.3); // Faster exit at higher levels
            const speed = baseSpeed * speedMultiplier;
            
            // Fly straight up and off screen
            enemy.y -= speed;
            enemy.element.style.top = enemy.y + 'px';
            
            // Remove enemy when it goes off screen
            if (enemy.y < -60) {
                if (enemy.element && enemy.element.parentNode) {
                    game.canvas.removeChild(enemy.element);
                }
                const index = game.enemies.indexOf(enemy);
                if (index > -1) {
                    game.enemies.splice(index, 1);
                }
                
                // Free up formation position
                if (enemy.formationIndex !== undefined) {
                    game.formationPositions[enemy.formationIndex].occupied = false;
                }
            }
        }
        
        function returnToFormation(enemy, speedMultiplier) {
            const speed = 3 * speedMultiplier;
            const dx = enemy.formationX - enemy.x;
            const dy = enemy.formationY - enemy.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 5) {
                enemy.x += (dx / distance) * speed;
                enemy.y += (dy / distance) * speed;
                enemy.element.style.left = enemy.x + 'px';
                enemy.element.style.top = enemy.y + 'px';
            } else {
                // Back in formation
                enemy.state = 'formation';
                enemy.x = enemy.formationX;
                enemy.y = enemy.formationY;
                enemy.element.style.left = enemy.x + 'px';
                enemy.element.style.top = enemy.y + 'px';
            }
        }
        
        function performCaptureAttack(enemy, speedMultiplier) {
            const speed = 3 * speedMultiplier;
            
            if (!enemy.capturedPlayer) {
                // Move towards player for capture
                const dx = game.player.x - enemy.x;
                const dy = game.player.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 50) {
                    enemy.x += (dx / distance) * speed;
                    enemy.y += (dy / distance) * speed;
                    enemy.element.style.left = enemy.x + 'px';
                    enemy.element.style.top = enemy.y + 'px';
                } else {
                    // Capture player
                    capturePlayer(enemy);
                }
            } else {
                // Return to formation with captured player
                returnToFormation(enemy, speedMultiplier);
            }
        }
        
        function moveBossRandomly(enemy, speedMultiplier, now) {
            const canvasSize = getCanvasDimensions();
            
            // Initialize boss movement properties if not set
            if (!enemy.bossMovement) {
                enemy.bossMovement = {
                    targetX: enemy.x,
                    targetY: enemy.y,
                    lastDirectionChange: now,
                    changeInterval: 2000 + Math.random() * 3000, // Change direction every 2-5 seconds
                    speed: 1.5 + (game.level * 0.1) // Slower, methodical movement
                };
            }
            
            // Check if it's time to change direction
            if (now - enemy.bossMovement.lastDirectionChange > enemy.bossMovement.changeInterval) {
                // Choose new random target within screen bounds
                const margin = 100; // Keep boss away from edges
                enemy.bossMovement.targetX = margin + Math.random() * (canvasSize.width - margin * 2);
                enemy.bossMovement.targetY = canvasSize.height * 0.1 + Math.random() * (canvasSize.height * 0.3); // Stay in upper area
                enemy.bossMovement.lastDirectionChange = now;
                enemy.bossMovement.changeInterval = 2000 + Math.random() * 3000; // Random interval
            }
            
            // Move towards target
            const dx = enemy.bossMovement.targetX - enemy.x;
            const dy = enemy.bossMovement.targetY - enemy.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 10) {
                const moveSpeed = enemy.bossMovement.speed * speedMultiplier;
                enemy.x += (dx / distance) * moveSpeed;
                enemy.y += (dy / distance) * moveSpeed;
                
                // Keep boss within screen bounds
                enemy.x = Math.max(50, Math.min(canvasSize.width - 150, enemy.x));
                enemy.y = Math.max(canvasSize.height * 0.05, Math.min(canvasSize.height * 0.45, enemy.y));
                
                enemy.element.style.left = enemy.x + 'px';
                enemy.element.style.top = enemy.y + 'px';
            }
        }
        
        // Capture player mechanics
        function capturePlayer(enemy) {
            if (game.capturedPlayer || !game.player) return;
            
            // Create captured player sprite
            game.capturedPlayer = {
                element: createSprite('player', enemy.x, enemy.y - 50),
                x: enemy.x,
                y: enemy.y - 50,
                capturingEnemy: enemy
            };
            
            // Hide original player temporarily
            game.player.element.style.display = 'none';
            
            enemy.capturedPlayer = game.capturedPlayer;
            enemy.state = 'returning';
            
            game.canvas.appendChild(game.capturedPlayer.element);
        }
        
        function rescuePlayer(enemy) {
            if (!enemy.capturedPlayer) return;
            
            // Create dual ship mode
            const rescuedShip = {
                element: createSprite('player', game.player.x - 60, game.player.y),
                x: game.player.x - 60,
                y: game.player.y,
                isDual: true
            };
            
            game.canvas.appendChild(rescuedShip.element);
            
            // Clean up captured player
            if (enemy.capturedPlayer.element && enemy.capturedPlayer.element.parentNode) {
                game.canvas.removeChild(enemy.capturedPlayer.element);
            }
            
            enemy.capturedPlayer = null;
            game.capturedPlayer = null;
            game.player.element.style.display = 'block';
            game.player.dualShip = rescuedShip;
        }
        
        function startCaptureAttack() {
            const capableEnemies = game.enemies.filter(e => e.canCapture && e.state === 'formation');
            if (capableEnemies.length === 0 || game.capturedPlayer) return;
            
            const enemy = capableEnemies[Math.floor(Math.random() * capableEnemies.length)];
            enemy.state = 'capturing';
        }

        // Move projectiles
        function moveProjectiles() {
            // Player projectiles - iterate backwards
            for (let index = game.projectiles.length - 1; index >= 0; index--) {
                const projectile = game.projectiles[index];
                if (!projectile || !projectile.element) continue;
                
                projectile.y -= projectile.speed;
                projectile.element.style.top = projectile.y + 'px';
                
                if (projectile.y < 0) {
                    if (projectile.element && projectile.element.parentNode) {
                        game.canvas.removeChild(projectile.element);
                    }
                    game.projectiles.splice(index, 1);
                }
            }
            
            // Enemy projectiles - iterate backwards
            for (let index = game.enemyProjectiles.length - 1; index >= 0; index--) {
                const projectile = game.enemyProjectiles[index];
                if (!projectile || !projectile.element) continue;
                
                projectile.y += projectile.speed;
                if (projectile.vx) {
                    projectile.x += projectile.vx; // Handle spread projectiles
                }
                projectile.element.style.top = projectile.y + 'px';
                projectile.element.style.left = projectile.x + 'px';
                
                // Check for shield reflection
                const now = Date.now();
                if (powerUps.active.shield && powerUps.active.shield > now && game.player && !projectile.reflected) {
                    const playerCenterX = game.player.x + 50;
                    const playerCenterY = game.player.y + 40;
                    const projCenterX = projectile.x + 10;
                    const projCenterY = projectile.y + 10;
                    
                    // Check if projectile is within shield radius (80px)
                    const distance = Math.sqrt(
                        Math.pow(projCenterX - playerCenterX, 2) + 
                        Math.pow(projCenterY - playerCenterY, 2)
                    );
                    
                    if (distance <= 80) {
                        // Reflect the projectile
                        projectile.speed = -Math.abs(projectile.speed); // Reverse direction
                        if (projectile.vx) projectile.vx = -projectile.vx; // Reverse horizontal velocity
                        projectile.reflected = true; // Mark as reflected to prevent multiple reflections
                        
                        // Convert to player projectile for hitting enemies
                        const reflectedProjectile = {
                            element: projectile.element,
                            x: projectile.x,
                            y: projectile.y,
                            speed: 8, // Set upward speed
                            explosive: false
                        };
                        
                        // Remove from enemy projectiles and add to player projectiles
                        game.enemyProjectiles.splice(index, 1);
                        game.projectiles.push(reflectedProjectile);
                        continue; // Skip rest of processing for this projectile
                    }
                }
                
                const canvasSize = getCanvasDimensions();
                if (projectile.y > canvasSize.height || projectile.x < 0 || projectile.x > canvasSize.width) {
                    if (projectile.element && projectile.element.parentNode) {
                        game.canvas.removeChild(projectile.element);
                    }
                    game.enemyProjectiles.splice(index, 1);
                }
            }
        }

        // Collision detection
        function checkCollisions() {
            // Debug: Check if we have power-ups and player
            if (powerUps.items.length > 0 && game.player) {
                // console.log('Checking collisions with', powerUps.items.length, 'power-ups');
            }
            
            // Player projectiles vs enemies - iterate backwards to avoid index issues
            for (let pIndex = game.projectiles.length - 1; pIndex >= 0; pIndex--) {
                const projectile = game.projectiles[pIndex];
                if (!projectile || !projectile.element) continue;
                
                for (let eIndex = game.enemies.length - 1; eIndex >= 0; eIndex--) {
                    const enemy = game.enemies[eIndex];
                    if (!enemy || !enemy.element) continue;
                    
                    if (projectile.x < enemy.x + 60 &&
                        projectile.x + 16 > enemy.x &&
                        projectile.y < enemy.y + 60 &&
                        projectile.y + 24 > enemy.y) {
                        
                        // Handle explosive shots (TNT power-up)
                        if (projectile.explosive) {
                            // Destroy enemies in explosion radius
                            for (let i = game.enemies.length - 1; i >= 0; i--) {
                                const targetEnemy = game.enemies[i];
                                const distance = Math.sqrt(
                                    Math.pow(enemy.x - targetEnemy.x, 2) + 
                                    Math.pow(enemy.y - targetEnemy.y, 2)
                                );
                                
                                if (distance < 120) { // Explosion radius
                                    if (targetEnemy.isBoss) {
                                        targetEnemy.health--;
                                        
                                        // Update boss health display
                                        updateBossHealth(targetEnemy.health, targetEnemy.maxHealth);
                                        
                                        // Visual indication of boss taking damage
                                        targetEnemy.element.style.filter = 'brightness(1.5)';
                                        setTimeout(() => {
                                            if (targetEnemy.element) {
                                                targetEnemy.element.style.filter = '';
                                            }
                                        }, 100);
                                        
                                        if (targetEnemy.health <= 0) {
                                            // Boss defeated by explosion
                                            if (targetEnemy.element && targetEnemy.element.parentNode) {
                                                game.canvas.removeChild(targetEnemy.element);
                                            }
                                            
                                            let points = 500 + (game.level - 1) * 50; // Boss explosion points
                                            if (targetEnemy.type === 'witch') points = 1000;
                                            else if (targetEnemy.type === 'evoker') points = 1500;
                                            else if (targetEnemy.type === 'ravager') points = 2000;
                                            else if (targetEnemy.type === 'warden') points = 2500;
                                            else if (targetEnemy.type === 'blaze') points = 1000;
                                            else if (targetEnemy.type === 'ghast') points = 1500;
                                            else if (targetEnemy.type === 'wither') points = 2500;
                                            
                                            game.score += points;
                                            game.enemiesDefeated++;
                                            game.enemies.splice(i, 1);
                                            
                                            // Hide boss health bar when boss is defeated
                                            hideBossHealth();
                                        } else {
                                            // Boss damaged by explosion
                                            let points = 50;
                                            game.score += points;
                                            document.getElementById('score').textContent = game.score;
                                            updateHighScore();
                                        }
                                    } else {
                                        // Normal enemy - dies in explosion
                                        if (targetEnemy.element && targetEnemy.element.parentNode) {
                                            game.canvas.removeChild(targetEnemy.element);
                                        }
                                        
                                        let points = 100 + (game.level - 1) * 10;
                                        if (targetEnemy.type === 'creeper') points = 150 + (game.level - 1) * 15;
                                        
                                        game.score += points;
                                        game.enemiesDefeated++;
                                        game.enemies.splice(i, 1);
                                    }
                                }
                            }
                        } else {
                            // Check if this enemy has captured player
                            if (enemy.capturedPlayer) {
                                rescuePlayer(enemy);
                            }
                            
                            // Handle enemy hit (bosses take multiple hits)
                            if (enemy.isBoss) {
                                enemy.health--;
                                
                                // Update boss health display
                                updateBossHealth(enemy.health, enemy.maxHealth);
                                
                                // Visual indication of boss taking damage
                                enemy.element.style.filter = 'brightness(1.5)';
                                setTimeout(() => {
                                    if (enemy.element) {
                                        enemy.element.style.filter = '';
                                    }
                                }, 100);
                                
                                if (enemy.health <= 0) {
                                    // Boss defeated
                                    if (enemy.element && enemy.element.parentNode) {
                                        game.canvas.removeChild(enemy.element);
                                    }
                                    
                                    let points = 500 + (game.level - 1) * 50; // Boss points
                                    if (enemy.type === 'witch') points = 1000;
                                    else if (enemy.type === 'evoker') points = 1500;
                                    else if (enemy.type === 'ravager') points = 2000;
                                    else if (enemy.type === 'warden') points = 2500;
                                    else if (enemy.type === 'blaze') points = 1000;
                                    else if (enemy.type === 'ghast') points = 1500;
                                    else if (enemy.type === 'wither') points = 2500;
                                    
                                    game.score += points;
                                    game.enemiesDefeated++;
                                    game.enemies.splice(eIndex, 1);
                                    
                                    // Hide boss health bar when boss is defeated
                                    hideBossHealth();
                                } else {
                                    // Boss still alive, just damaged
                                    let points = 50; // Small points for hitting boss
                                    game.score += points;
                                    document.getElementById('score').textContent = game.score;
                                    updateHighScore();
                                }
                            } else {
                                // Normal enemy - dies in one hit
                                if (enemy.element && enemy.element.parentNode) {
                                    game.canvas.removeChild(enemy.element);
                                }
                                
                                let points = 100 + (game.level - 1) * 10;
                                if (enemy.type === 'creeper') points = 150 + (game.level - 1) * 15;
                                
                                game.score += points;
                                game.enemiesDefeated++;
                                game.enemies.splice(eIndex, 1);
                            }
                            
                            // Spreading fire effect
                            if (powerUps.active.spreadingFire && powerUps.active.spreadingFire > Date.now()) {
                                // Create visual fire spreading effect
                                createFireSpreadEffect(enemy.x + 20, enemy.y + 20);
                            }
                        }
                        
                        // Remove projectile
                        if (projectile.element && projectile.element.parentNode) {
                            game.canvas.removeChild(projectile.element);
                        }
                        game.projectiles.splice(pIndex, 1);
                        
                        sounds.enemyHit();
                        document.getElementById('score').textContent = game.score;
                        updateHighScore();
                        
                        break; // Exit inner loop since projectile is destroyed
                    }
                }
            }
            
            // Enemy projectiles vs player - iterate backwards
            for (let index = game.enemyProjectiles.length - 1; index >= 0; index--) {
                const projectile = game.enemyProjectiles[index];
                if (!projectile || !projectile.element) continue;
                
                if (projectile.x < game.player.x + 100 &&
                    projectile.x + 20 > game.player.x &&
                    projectile.y < game.player.y + 80 &&
                    projectile.y + 20 > game.player.y) {
                    
                    // Check for invincibility (Golden Apple)
                    const now = Date.now();
                    if (powerUps.active.invincibility && powerUps.active.invincibility > now) {
                        // Remove projectile but no damage
                        if (projectile.element && projectile.element.parentNode) {
                            game.canvas.removeChild(projectile.element);
                        }
                        game.enemyProjectiles.splice(index, 1);
                        continue;
                    }
                    
                    // Safe removal with existence check
                    if (projectile.element && projectile.element.parentNode) {
                        game.canvas.removeChild(projectile.element);
                    }
                    game.enemyProjectiles.splice(index, 1);
                    
                    sounds.hit();
                    
                    // Handle projectile damage (witch snowballs cause 2 damage)
                    const damage = projectile.damage || 1;
                    game.lives -= damage;
                    document.getElementById('lives').textContent = game.lives;
                    
                    if (game.lives <= 0) {
                        gameOver();
                    }
                }
            }
            
            // Player vs power-ups - check collision
            for (let index = powerUps.items.length - 1; index >= 0; index--) {
                const powerUp = powerUps.items[index];
                if (!powerUp || !powerUp.element) continue;
                
                // Debug: Log positions
                // console.log('PowerUp:', powerUp.x, powerUp.y, 'Player:', game.player.x, game.player.y);
                
                // Simple overlap detection
                const playerCenterX = game.player.x + 50; // Player width is 100
                const playerCenterY = game.player.y + 40; // Player height is 80
                const powerUpCenterX = powerUp.x + 20; // PowerUp width is 40
                const powerUpCenterY = powerUp.y + 20; // PowerUp height is 40
                
                const distance = Math.sqrt(
                    Math.pow(playerCenterX - powerUpCenterX, 2) + 
                    Math.pow(playerCenterY - powerUpCenterY, 2)
                );
                
                if (distance < 60) { // Collection radius
                    console.log('PowerUp collected!', powerUp.type);
                    
                    // Collect power-up
                    if (powerUp.element && powerUp.element.parentNode) {
                        game.canvas.removeChild(powerUp.element);
                    }
                    powerUps.items.splice(index, 1);
                    
                    activatePowerUp(powerUp.type);
                    sounds.shoot(); // Collection sound
                    break; // Exit loop after collecting one power-up
                }
            }
            
            // Player projectiles vs power-ups (alternative collection method)
            for (let pIndex = game.projectiles.length - 1; pIndex >= 0; pIndex--) {
                const projectile = game.projectiles[pIndex];
                if (!projectile || !projectile.element) continue;
                
                for (let index = powerUps.items.length - 1; index >= 0; index--) {
                    const powerUp = powerUps.items[index];
                    if (!powerUp || !powerUp.element) continue;
                    
                    if (projectile.x < powerUp.x + 40 &&
                        projectile.x + 16 > powerUp.x &&
                        projectile.y < powerUp.y + 40 &&
                        projectile.y + 24 > powerUp.y) {
                        
                        // Collect power-up by shooting it
                        if (powerUp.element && powerUp.element.parentNode) {
                            game.canvas.removeChild(powerUp.element);
                        }
                        if (projectile.element && projectile.element.parentNode) {
                            game.canvas.removeChild(projectile.element);
                        }
                        
                        powerUps.items.splice(index, 1);
                        game.projectiles.splice(pIndex, 1);
                        
                        activatePowerUp(powerUp.type);
                        sounds.shoot(); // Collection sound
                        break;
                    }
                }
            }
            
            // Direct enemy-player collision for life loss
            game.enemies.forEach(enemy => {
                if (enemy.x < game.player.x + 100 &&
                    enemy.x + 60 > game.player.x &&
                    enemy.y < game.player.y + 80 &&
                    enemy.y + 60 > game.player.y) {
                    
                    // Enemy hit player directly
                    sounds.hit();
                    game.lives--;
                    document.getElementById('lives').textContent = game.lives;
                    
                    // Remove the enemy that hit the player
                    if (enemy.element && enemy.element.parentNode) {
                        game.canvas.removeChild(enemy.element);
                    }
                    const index = game.enemies.indexOf(enemy);
                    if (index > -1) {
                        game.enemies.splice(index, 1);
                    }
                    
                    if (game.lives <= 0) {
                        gameOver();
                    }
                }
            });
        }

        // Level complete
        function levelComplete() {
            // Hide boss health bar when level is complete
            hideBossHealth();
            
            // Reset boss creation flag for next level
            game.bossCreated = false;
            game.levelCompleting = false;
            
            game.level++;
            document.getElementById('level').textContent = game.level;
            game.enemySpeed += 0.3;
            
            // Bonus life for completing level
            game.lives++;
            document.getElementById('lives').textContent = game.lives;
            
            // Bonus points for completing level
            const levelBonus = game.level * 500;
            game.score += levelBonus;
            document.getElementById('score').textContent = game.score;
            updateHighScore();
            
            createEnemies();
        }
        
        // Player wins (defeat all enemies in level)
        function playerWins() {
            // Prevent multiple calls
            if (game.levelCompleting) return;
            game.levelCompleting = true;
            
            gameStats.wins++;
            document.getElementById('wins').textContent = gameStats.wins;
            saveStats();
            levelComplete();
        }

        // Game over
        function gameOver() {
            game.gameRunning = false;
            document.getElementById('gameOver').style.display = 'block';
            sounds.gameOver();
            
            gameStats.losses++;
            document.getElementById('losses').textContent = gameStats.losses;
            updateHighScore();
            saveStats();
        }

        // Clear game entities only (not UI elements)
        function clearGameEntities() {
            // Remove all sprites but keep UI elements
            const sprites = game.canvas.querySelectorAll('.sprite');
            sprites.forEach(sprite => {
                if (sprite.parentNode) {
                    sprite.parentNode.removeChild(sprite);
                }
            });
        }

        // Restart game
        function restartGame() {
            // Clear only game entities, not UI
            clearGameEntities();
            
            // Hide boss health bar when restarting game
            hideBossHealth();
            
            // Reset game state
            game.player = null;
            game.capturedPlayer = null;
            game.enemies = [];
            game.projectiles = [];
            game.enemyProjectiles = [];
            game.score = 0;
            game.lives = 3;
            game.gameRunning = true;
            game.gameStarted = true;
            game.level = 1;
            game.bossEntranceInProgress = false;
            game.bossCreated = false;
            game.levelCompleting = false;
            game.enemiesDefeated = 0;
            game.formationPositions = [];
            game.enemySpawnQueue = [];
            game.lastEnemySpawn = 0;
            game.formationComplete = false;
            
            // Update UI displays
            document.getElementById('score').textContent = game.score;
            document.getElementById('lives').textContent = game.lives;
            document.getElementById('level').textContent = game.level;
            document.getElementById('gameOver').style.display = 'none';
            
            // Reinitialize
            initPlayer();
            createEnemies();
        }

        // Switch dimension function  
        function switchDimension(dimension) {
            const body = document.body;
            
            // Remove existing dimension classes
            body.classList.remove('nether-dimension');
            
            // Apply dimension-specific styling
            if (dimension === 'nether') {
                body.classList.add('nether-dimension');
            }
            
            game.selectedDimension = dimension;
        }

        // Start the game
        function startGame() {
            // Apply selected dimension
            switchDimension(game.selectedDimension);
            game.gameStarted = true;
            game.gameRunning = true;
            game.bossEntranceInProgress = false;
            game.bossCreated = false;
            game.levelCompleting = false;
            
            // Hide boss health bar when starting game
            hideBossHealth();
            
            // Hide start screen
            document.getElementById('startScreen').classList.add('hidden');
            
            // Stop start music
            const startMusic = document.getElementById('startMusic');
            startMusic.pause();
            
            // Initialize game
            createEnemies();
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            game.keys[e.code] = true;
            
            // Start game with Enter key
            if (e.code === 'Enter' && !game.gameStarted) {
                e.preventDefault();
                startGame();
                return;
            }
            
            // Try to play start music on first interaction if not started
            if (!game.gameStarted) {
                const startMusic = document.getElementById('startMusic');
                startMusic.play().catch(() => {});
            }
            
            if (e.code === 'Space' && game.gameRunning) {
                e.preventDefault();
                shoot();
            }
            
            if (e.code === 'KeyR' && !game.gameRunning && game.gameStarted) {
                restartGame();
            }
            
        });

        document.addEventListener('keyup', (e) => {
            game.keys[e.code] = false;
        });

        // Dimension selection event listeners
        document.addEventListener('DOMContentLoaded', () => {
            const dimensionOptions = document.querySelectorAll('.dimension-option');
            
            dimensionOptions.forEach(option => {
                option.addEventListener('click', () => {
                    // Remove selected class from all options
                    dimensionOptions.forEach(opt => opt.classList.remove('selected'));
                    
                    // Add selected class to clicked option
                    option.classList.add('selected');
                    
                    // Update game state
                    game.selectedDimension = option.dataset.dimension;
                });
            });
        });

        // Game loop
        function gameLoop() {
            if (game.gameRunning) {
                movePlayer();
                moveEnemies();
                moveProjectiles();
                movePowerUps();
                moveFireSpreadEffects();
                updateShieldEffect();
                updateFreezeEffect();
                enemyShoot();
                checkCollisions();
                spawnPowerUp();
                updatePowerUpDisplay();
                
                // Check win condition - prevent multiple level completions
                if (game.enemies.length === 0 && !game.bossEntranceInProgress && !game.levelCompleting) {
                    // For boss levels, only win if boss was created and defeated
                    const isBossLevel = game.level % 5 === 0;
                    if (!isBossLevel || (game.bossCreated && game.totalEnemiesInLevel > 0)) {
                        playerWins();
                    }
                }
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Initialize game
        initUI();
        initPlayer();
        
        // Start background music
        const startMusic = document.getElementById('startMusic');
        startMusic.volume = 0.3;
        
        // Auto-play music (may be blocked by browser)
        startMusic.play().catch(e => {
            console.log('Music autoplay blocked, will start when user interacts');
        });
        
        gameLoop();
    </script>
</body>
</html>